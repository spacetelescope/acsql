%% bourque_cosc880.tex
%% Matthew Bourque

\documentclass[10pt,journal,compsoc]{IEEEtran}

% imports
\usepackage{color}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{ragged2e}
\usepackage{subfig}

% *** CITATION RELATED PACKAGES ***
\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% Colors
\definecolor{gray}{gray}{0.85}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% listings styles
\lstdefinestyle{code}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{magenta},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\footnotesize\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}


\begin{document}

% Title
\title{The Hubble Space Telescope Advanced Camera for Surveys Quicklook Application}


% Authors
\author{Matthew~Bourque\textsuperscript{1}, Sara~Ogaz\textsuperscript{1}, Alex~Viana\textsuperscript{2}, Meredith~Durbin\textsuperscript{3}, and Norman Grogin\textsuperscript{1}\\
\begin{flushleft}
{\scriptsize [1] Space Telescope Science Institute, Baltimore, Maryland 21218. email: bourque@stsci.edu, ogaz@stsci.edu, grogin@stsci.edu}\\
{\scriptsize [2] Terbium Labs, Baltimore, Maryland 21201. email: alexcostaviana@gmail.com}\\
{\scriptsize [3] Dept. of Astronomy, The University of Washington, Box 351580, U.W. Seattle, Washington, 98195, email:mdurbin@uw.edu}
\end{flushleft}
\thanks{Manuscript received Month DD, YYYY}}

% Abstract
\IEEEtitleabstractindextext{%
\justify
\begin{abstract}
The Hubble Space Telescope (HST) Advanced Camera for Surveys (ACS) instrument has been acquiring thousands of astronomical images
each year since its installation in 2002.  The ACS Quicklook Application (\texttt{acsql}) provides
a means for users to discover and interact with these data through a database-driven web application.  The system is comprised of
several components: (1) A $\sim$40 TB network file system, which stores all on-orbit ACS data files on disk, (2) a
\texttt{MySQL} database, which stores observational metadata in a normalized relational form and allows users to build custom datasets
based on obseravational parameters, (3) A Python/\texttt{Flask}-based web application, which allows users to view
``Quicklook'' JPEG images of any publicly-available ACS data along with its metadata, and (4) a Python code library, which
provides a platform on which users can build automated instrument calibration and monitoring routines.  The \texttt{acsql} application
may be extended to support the forthcoming James Webb Space Telescope (JWST) mission, which is scheduled to launch in October, 2018.
\end{abstract}}


% make the title area
\maketitle
\IEEEdisplaynontitleabstractindextext
\IEEEpeerreviewmaketitle


% Introduction
\IEEEraisesectionheading{\section{Introduction} \label{chap1}}
The Advanced Camera for Surveys (ACS) is a third-generation imaging instrument on board the Hubble Space Telescope (HST), and was
installed in 2002 during Servicing Mission 3B (shuttle mission STS-109)[1]. It is comprised of three detectors: (1) the Wide Field Camera
(WFC), which is designed for wide-field imaging and spectroscopy in visible to near-infrared wavelengths, (2) the High Resolution Channel,
which is designed for high resolution near-ultraviolet to near-infrared wavelength images and coronography, and (3) the Solar Blind
Channel (SBC), desingned for far-ultraviolet imaging and spectroscopy.  ACS expererienced an electronics failure in 2007 that affected
the WFC and HRC detectors, until 2009 when astronauts succesfully restored the WFC detector during Servicing Mission 4[2]; the HRC still
remains unoperational.

Despite this electronics filure, the ACS instrument has been steadily acquiring astronomical images over its 15 on-orbit lifetime.
Figure \ref{fig1} shows an estimate of the number of observations over time for each of the three detectors.  To date, there have been
nearly 200,000 observations total.  Further information about the ACS instrument including its history, configuration, performance, and
scientific capability can be found in the ACS Instrument Handbook[3].

% Figure for ACS observations over time
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/num_obs.png}
\caption{The number of observations over time for each of the three detectors on ACS.}
\label{fig1}
\end{figure}

ACS data, along with the data from the other HST instruments past and present (e.g. The Wide Field Camera 3 (WFC3), The Cosmic Origins
Spectrography (COS), etc.), are publicly available and primarily stored in the Barbara A. Mikulski Archive for Space Telescopes
(MAST)\footnote{named after the U.S. Senator from Maryland who has been a pivitol political driving force behind the manned servicing
missions, the Hubble Space Telescope, and the forthcoming James Webb Space Telescope}[4]. Through MAST, users can request and retreive
data for any publicly-available dataset via \texttt{ftp}, \texttt{sftp}, or DVD by mail\footnote{Not all HST data are publicly available;
most HST data of scientific targets are considered proprietary for up to one calendar year, after which they are publicly released.}. Like most
other astronomical data, ACS data are stored using the Flexible Image Transport System (FITS) data format[5].  This data format has several
unique characteristics, as will be discuessed in section \ref{sec1.1}.

The ACS Quicklook Application (hereinafter referred to as ``\texttt{acsql}") is a Python-based application for discovering, viewing, and
querying all publicly-available ACS data.  It consists of several major components: (1) A filesystem that stores ACS instrument data files
and ``Quicklook" JPEGs in an organized Network File System (NFS) (hereinafter referred to as the ``\texttt{acsql} filesystem"), (2) A
\texttt{MySQL} database that stores observational metadata of each observation (hereinafter referred to as the ``\texttt{acsql} database"),
(3) A Python/\texttt{Flask}-based web application for interacting with the filesystem and database (hereinafter referred to as the
``\texttt{acsql} web application"), and (4) A Python code library that contains software for connecting to the database, ingesting new data,
logging production code execution, and building/maintaining the database and web application (hereinafter referred to as the ``\texttt{acsql} library"
or ``\texttt{acsql} package".  Each of these subsystems are explained in further detail in Chapter \ref{chap3} (Methodology).

This paper outlines ACS Quicklook application as part of the Towson University Computer Science Masters Program Graduate Project.  The remaining
sections in this chapter discuss the motivation and use cases for this application, as well as details on the underlying data structure on
which this project was built.  Chapter \ref{chap2} discusses related work to this project and how the \texttt{acsql} application compares.
Chapter \ref{chap3} details the implementations of each of the \texttt{acsql} components.  Chapter \ref{chap4} outlines the results of the project, namely
the project deliverables.  Lastly, chapters \ref{chap5} and \ref{chap6} conclude the paper with a discussion of possible extensions and modifications to
the application.

We note that the work that went into this project by the authors was accomplished on behalf of the Space Telescope Science Institute (STScI)
located in Baltimore, Maryland.  STScI is the home institution for instrument, data, and user support of HST, the forthcoming James Webb Space
Telescope (JWST), and MAST.  STScI is part of the Association of Universities for Research in Astronomy (AURA)[6].


\subsection{Data Structure} \label{sec1.1}

The design of \texttt{acsql}, particularly the \texttt{acsql} database, is heavily dependant on the underlying data structure of ACS FITS files.
As such, it is important for the reader to have a conceptual understanding of this data structure and thus the following sections are dedicated to
providing an overview on the FITS data format and ACS-specific intricacies.


\subsubsection{Filenames} \label{sec1.1.1}

The data from each ACS observation is contained within a FITS data file, and is named in a consistent fashion:\newline

\texttt{$<$rootname$>$\_$<$filetype$>$.fits}\newline

\noindent where each \texttt{$<$rootname$>$} consists of nine unique alpha-numeric characters, and \texttt{$<$filetype$>$} is one of several possible
three-character filetype options (discussed in section \ref{sec1.1.4}).  For example, one ACS observation has the filename \texttt{j6mf16lhq\_raw.fits}
(Principle Investigator Gary Bernstein, observation date \texttt{2016-09-22}).  Each character in the 9-character \texttt{rootname} has a specific meaning,
and is discussed in section 5.2 of the Introduction to the HST Data Handbooks[7].  The \texttt{.fits} extension at the end of the filename signifies
that the file is of the FITS data format.

The unique 9-character \texttt{rootname} is associated with an individual, distinct ACS observation. However, it should be noted that only the first
eight characters of the 9-character \texttt{rootname} is truly unique; the last character, which identifies the source of data transmission from the
telescope\footnote{For example, \texttt{q} = solid-state recorder, \texttt{s} = retransmitted solid-state recorder}, has several possible values.  However,
varying values of the last character do not associate with different observations.  For this reason, as will be discussed in section \ref{sec3.5}, we adopt
an 8-character \texttt{rootname} as a primary key for the \texttt{acsql} database tables to denote unique ACS observations.


\subsubsection{FITS file structure} \label{sec1.1.2}

Each ACS FITS file consists of several `extensions', with each extension serving a specific purpose to describe a particular aspect of the observation.
Each extension consists of two parts: (1) an extension `header', which contain key/value pairs describing image metadata (for example,
\texttt{DATE-OBS = '2016-09-22'} indicates that the date the particular observation was made was \texttt{2016-09-22}), and (2) the extension data,
which may be a binary table or, more commonly, a multi-dimensional array of detector pixel values.

The type of extension data can also vary.  The most common extension data types are (1) `science' (\texttt{SCI}), in which the data values are the measure
the brightness of the astronomical scene, (2) `error' (\texttt{ERR}), in which the data values are the measure of the uncertainty in the pixel values of the
\texttt{SCI} extension, and (3) `data quality' (\texttt{DQ}), in which the data values are 16-bit flags that describe the quality of the pixel values for
the detector (for example, they may indicate that certain pixels were affected by cosmic rays durring the observation).  Typically, for a given file,
the 1st extension is the \texttt{SCI} extension, the 2nd extension is the \texttt{ERR} extension, and the 3rd extension is the \texttt{DQ} extension.
Furthermore, the 0th extension typically has no extension data and only an extension header that contains metadata that is common to all
extensions.  This is referred to as the `primary header'.

Tables \ref{tab1} and \ref{tab2} describe the different extensions of ACS FITS files for each of the three ACS detectors.  Note that there are two sets
of \texttt{SCI}/\texttt{ERR}/\texttt{DQ} extensions for WFC, since WFC is comprised of two separate CCD chips.

% Table for WFC extenions
\begin{table}[!t]
\renewcommand{\arraystretch}{1.5}
\caption{ACS/WFC FITS file extensions}
\label{tab1}
\centering
\begin{tabular}{|c|l|c|c|}
\hline
\rowcolor{gray} Extension & \multicolumn{1}{p{2cm}|}{\centering Purpose} & \multicolumn{1}{p{1.5cm}|}{\centering Image Dimensions \\ (pixels)} & Data Type \\
\hline
0 & Primary header & -- & String \\
\hline
1 & SCI, Chip 2 & (4096, 2048) & Float \\
\hline
2 & ERR, Chip 2 & (4096, 2048) & Float \\
\hline
3 & DQ, Chip 2 & (4096, 2048) & Integer \\
\hline
4 & SCI, Chip 1 & (4096, 2048) & Float \\
\hline
5 & ERR, Chip 1 & (4096, 2048) & Float \\
\hline
6 & DQ, Chip 1 & (4096, 2048) & Integer \\
\hline
\end{tabular}
\end{table}

% Table for HRC and SBC extenions
\begin{table}[!t]
\renewcommand{\arraystretch}{1.5}
\caption{ACS/HRC and ACS/SBC FITS file extensions}
\label{tab2}
\centering
\begin{tabular}{|c|l|c|c|}
\hline
\rowcolor{gray} Extension & \multicolumn{1}{p{2cm}|}{\centering Purpose} & \multicolumn{1}{p{1.5cm}|}{\centering Image Dimensions \\ (pixels)} & Data Type \\
\hline
0 & Primary header & -- & String \\
\hline
1 & SCI & (1024, 1024) & Float \\
\hline
2 & ERR & (1024, 1024) & Float \\
\hline
3 & DQ & (1024, 1024) & Integer \\
\hline
\end{tabular}
\end{table}


Over the years, there have been several tools written in various programming languages to read the data of FITS files into memory and automatically convert
their extension data into multi-dimensional array data types as well as their extension headers to dictionary or string data types.  For this project, the
\texttt{astropy.io.fits} Python module is used extensively to read and interact with the data of ACS FITS files[8].


\subsubsection{FITS file extension headers} \label{sec1.1.3}

As mentioned in section \ref{sec1.1.2}, each FITS extension contains a `header', which contains key/value pairs of metadata associated with the extension data.
Such metadata includes various data that describes the astronomical observation (e.g. target name, exposure time, principle investigator name, etc.), telemetry
of ACS instrument or HST in general at the time of observation (e.g. temperature of the ACS instrument, orientation of the telescope pointing, position of the
telescope relative to Earth, etc.) or the FITS file itself (e.g. the number of extensions, file creation date, etc.). A subsection of an example header is shown
in Figure \ref{fig2}.  Note that extension headers may contain a large number of keyword/value pairs; some extension headers contain upwards of 300 keywords,
while others may contain only $\sim$40 keywords.

% Figure for header example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/header_example.png}
\caption{A section of an example header, taken from the 0th extension of the file \texttt{j6mf6lhq$\_$raw.fits}.}
\label{fig2}
\end{figure}


\subsubsection{FITS filetypes for ACS} \label{sec1.1.4}

As discusses in section \ref{sec1.1.1}, each ACS observation may result in several FITS filetypes. Each filetype has a specific scientific application and
the set of available filetypes for a given observation is dependent on the characteristics of the observation, the details of which are beyond the scope of this
paper.  These details can however be ascertained from the ACS Data Handbook[9].  To provide some context, below we give a brief description of each possible
filetype that a given observation may contain:

\begin{itemize}
  \item \textbf{raw} - The raw, uncalibrated data that comes directly from HST
  \item \textbf{flt} - nominally calibrated data
  \item \textbf{flc} - nominally calibrated data plus corrected for Charge Transfer Efficieny (CTE) deficits.
  \item \textbf{drz} - Geometric distortion-corrected data
  \item \textbf{drc} - Geometric distrotion-corrected plus CTE corrected data
  \item \textbf{spt} - Telescope telemetry data
  \item \textbf{jit} - Telescope pointing data
  \item \textbf{jif} - Telescope drifting data
  \item \textbf{crj} - Cosmic ray rejected data
  \item \textbf{crc} - Cosmic ray rejected plus CTE corrected data
  \item \textbf{asn} - Observation association table.
\end{itemize}

As noted earlier, a given observation may not result in the set of all possible filetypes. For example, the observation \texttt{j6mf16lhq} only results in the
filetypes \texttt{raw}, \texttt{flt}, \texttt{jit}, \texttt{jif}, and \texttt{spt}.


\subsection{Key Metadata} \label{sec1.2}

There are several metadata key/value pairs that are particulary important for the \texttt{acsql} application, and namely the web application, which often
presents these metadata to the user.  To provide some context for the remainder of this paper, these metadata are briefly described below.  Note that the
\texttt{rootname} and \texttt{proposal$\_$type} are not metadata from extension headers, but rather are metadata that were explicitly added to the
\texttt{acsql} database schema.\newline

\textit{APERTURE} - The portion of the \texttt{WFC}, \texttt{HRC}, or \texttt{SBC} detector that that was used during an observation.  This can either be the
entire detector (e.g. \texttt{WFC}, referred to as a ``full-frame image''), or a subsection of the detector (e.g. \texttt{WFC1-1K}, refered to as a ``subarray'').\\

\textit{DATE-OBS} - The date of the observation in the format \texttt{YYYY-MM-DD}, measured in Universal Time (e.g. \texttt{'2017-08-05'}).\\

\textit{DEC$\_$TARG} - The declination of the target (i.e. the angular distance the target north or south of the celestial equator) (e.g. \texttt{41.2842}).\\

\textit{DETECTOR} - The detector used for the observation.  Can either be \texttt{WFC}, \texttt{HRC}, or \texttt{SBC}.\\

\textit{EXPFLAG} - Indicates if an observation was interrupted (e.g. \texttt{INTERRUPTED}) or not (e.g \texttt{NORMAL}).\\

\textit{EXPSTART} - The exposure start time of the observation, in units of Modified Julian Date (e.g. \texttt{52473.8}).\\

\textit{EXPTIME} - The exposure duration of the observation, in units of seconds (e.g. \texttt{1000.0}).\\

\textit{FILTER1} - The selected element from the \texttt{ACS} filter wheel \# 1 (e.g. \texttt{F606W}).\\

\textit{FILTER2} - The selected element from the \texttt{ACS} filter wheel \# 2 (e.g. \texttt{F814W}).\\

\textit{IMAGETYP} - The type of exposure for the observation (e.g. \texttt{BIAS}, \texttt{EXT}, etc.).\\

\textit{OBSTYPE} - The type of observation, either \texttt{IMAGING}, \texttt{SPECTROSCOPIC}, \texttt{CORONOGRAPHIC}, or \texttt{INTERNAL}.\\

\textit{proposal$\_$type} - The type of proposal that the observation belongs to, such as Calibration (i.e. \texttt{CAL}) or General Observer (i.e. \texttt{GO}).\\

\textit{PROPOSID} - The 4 or 5-digit proposal number that the observation belongs to (e.g. \texttt{10695}).\\

\textit{RA$\_$TARG} - The right ascension of the target (i.e. the angular distance of the target east and west on the celestial sphere) (e.g. \texttt{49.5375}).\\

\textit{rootname} - The 8-character unique rootname of the observation (e.g. \texttt{j59l5401}).\\

\textit{SUBARRAY} - A boolean flag that indicates if the observation is a full-frame \texttt{APERTURE} (i.e. \texttt{0}) or a subarray \texttt{APERTURE} (i.e. \texttt{1}).\\

\textit{TARGNAME} - The name of the target (e.g. \texttt{M87}, \texttt{NGC-4536}, \texttt{ANDROMEDA-I}, etc.).\\

\textit{TIME-OBS} - The time of the start of the observation in the format \texttt{HH:MM:SS}, measured in Universal Time (e.g. \texttt{14:21:56}).\\


\subsection{Motivation} \label{sec1.3}

The motivation for the \texttt{acsql} system is driven by several limitations
of the FITS file structure as well as the current capabilities of MAST from specific
user perspectives. Some of these limitations are described below, along with the
way the ACS Quicklook application aims to address them.  We also discuss the
inteded users of the application and the expected use cases.\newline

\subsubsection{Data retreival letency} \label{sec1.3.1}

Currently, users who wish to retreive data from MAST must submit a retreival
request via the MAST online interface. Once the retreival request is processed
(usually automatically unless it is a request of a large number of datasets),
the data are either transfered to the user directly via \texttt{sftp}, transfered
to a ``staging area'' in which the user can log into and copy the data via
\texttt{ftp} at their leisure, or sent by mail via DVD, depending on which option
the user selects.  In the case of any one of these options, the time between a
download request and the the time in which the user has fully retreived the data
may be a significant amount of time.  In the fastest scenario of the
\texttt{sftp} option, a typical request can take minutes to hours to be completed.
Furthermore, there are limited options available for programmatically obtaining new
data; users who wish to retreive the latest availble data must (1) discover which
datasets are of interest via a query to the MAST database, (2) construct a download
request, (3) submit the download request, and (4) await the data.

The ACS Quicklook system attempts to circumnavigate this retreival process by making
the full data products instantly available via read-only access of the \texttt{acsql}
filesystem, as well as a subset of the data products (and corresponding metadata)
instantly available to view through the web application.  By having all of the available
data centrally located, users need not to go through this request process; data can
be directly read from the storage areas on disk.

\subsubsection{File I/O} \label{sec1.3.2}

A significant limitation of the FITS file format is the amount of time required for
file I/O.  With users often finding themselves analyzing hundreds to thousands of
images, this file I/O can be quite a burden on the total processing time of such
analysis.  \texttt{acsql} attempts to mitigate this processing time by storing the
valuable image metadata that users often seek in a relational database.

Queries to the \texttt{acsql} database prove to be much faster than opening and
closing individual FITS files, and the difference in data retreival times increases
linearly with increasing amount of files.  Consider an example situation in which a
user wishes to retreive the date of observation (i.e. the \texttt{DATE-OBS} header
keyword in the 0th extension of a \texttt{raw} FITS file) for one thousand files.
Figure N shows that the total time required to gather this information is $\sim$N times less
when quering the \texttt{acsql} database than when retreiving the data directly from
the FITS files.

% Figure for IO time profile
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/fileio_time.png}
\caption{The amount of time it takes to retreive the \texttt{DATE-OBS} header keyword
from a varying number of ACS data files via reading the FITS file using the
\texttt{astropy.io.fits} module (red) and querying the \texttt{acsql} database (green)}
\label{fig3}
\end{figure}

In order to build the \texttt{acsql} database, each ACS FITS file must ultimately be
opened in order to retrieve the header information.  However, this operation is only
performed once and needed not to be performed by the user.

\subsubsection{Data redundancy} \label{1.3.3}

As will be discussed in section 1.3.5, the primary user base for \texttt{acsql} is a group
of ACS instrument analysts who use ACS data on a daily basis.  As such, each user may
require access to a varying amount of ACS data over time; some data may be useful for
their work one day, but not the next, while some data is consistently being analyzed over
time.  Furthermore, instrument analysts may share the need for specific data with one or
more of their colleagues. Consider a situation in which two instrument anaysist require data
from a proposal 11655. Traditionally, for the two instrument analysts to obtain the data they
need, they would have to submit a download request to MAST for data from 11655 and store the data
in personal directories.  Unless this effort is explicitly coordinated amongst the two
individuals, they will each likely download and store a copy of this data, when in reality, only
one copy is needed.  As illustrated, this workflow leads to possible data redundancy.  With
the ACS instrument team employing roughly a dozen instrument analysts, the scale of this
data redundancy can grow quite large.

Recently, MAST has mitigated this issue through what is known as the MAST public cache, which is
a centrally-located, organized network file system that stores all publicly-available HST data and
is internal to STScI.  THe \texttt{acsql} filesystem is built on top of the MAST public cache
to provide accessibility to all ACS data in one central location.  Furthermore, the \texttt{acsql}
application provides the \texttt{acsql} database (for observational metadata needs) and the
\texttt{acsql} web application (for quick data viewing).  With the combination of these three
components, instrument analysts have instant access to all ACS data at any time; no need for
coordination amongst other instrument analysts or storage of separate copies.

\subsubsection{Data discovery} \label{sec1.3.4}

As will be discussed in section 1.3.5, ACS instrument analysts often wish to know which datasets
(i.e. rootnames) exist for various observational parameters.  For example, one may need to
analyze data that were observed between a specific time period, or observed with a specific pointing
on the sky.  Conversely, an instrument analyst may have knowledge of specific rootnames, but wish
to know the observational parameters associated with them.

MAST has tools which allow users to discover rootnames and/or parameters for observations, such as
the MAST portal, which is a public-facing online data discovery tool for various data collections such
as HST data, high level science products, and catalogs of astronomical source positions (further
discussed in Chapter 3) (MAST, 2017).  The MAST portal offers features that may be of particular
interest to research astronomers at academic institutions, for example, an image of the location of
the scientific target on the sky (`AstroView'), an interactive GUI for displaying results, and an
option to export results to various file types.  An example query of this tool is shown in Figure N.

% Figure for MAST portal example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/mast_portal.png}
\caption{An example of a query to the MAST data discovery portal.}
\label{fig4}
\end{figure}

Though the MAST portal has many useful features, there are some limitations to the tool from the
perspective of an instrument analyst at STScI.  One such limitation is that the observational metadata
available through the MAST portal does not include all of the observational metadata available in
the FITS headers; it is limited to a small subset of header keywords, mainly from the RAW and FLT
filetypes, amongst other MAST-generated metadata (e.g. `Target Classification').  Another limitation
is that the result of a query is keyed off of an `Observation ID' as opposed to a traditional
\texttt{rootname}.  The `Observation ID' may map to one or more individual observations (and thus
one or more individual \texttt{rootnames}), making it difficult for instrument analysts to discover
which \texttt{rootnames} (and thus data files) that are associated with the observational metadata
they seek.  Similarly, this makes it difficult to use the MAST portal to query for information based
on an individual observation.

The \texttt{acsql} application aims to provide an intuitive, one-to-one correspondance between the
FITS header values and the \texttt{acsql} database schema.  The column names in the header tables of
the \texttt{acsql} database exactly match the names found in the FITS headers, and each extension
of each ACS filetype is supported.  Furthermore, the primary key of each header table in the database
is the \texttt{rootname} that instrument analysts use in their day-to-day work, as opposed to an
`Observation ID'.  With this configuration, it is straightforward to discover data via a database
query using header keywords.


\subsubsection{Use Cases} \label{sec1.3.5}

The intended primary users of the \texttt{acsql} application are ACS isntrument analysts that
work for the ACS instrument team at STScI.  ACS instrument analysts use ACS data frequently
in their day-to-day work, using the data to help calibrate, monitor, and characterize the
various aspects and behaviors of the ACS instrument.  On any given day, an instrument analyst
may need to analyze data from a number of observing modes, time periods, or filetypes.  In this
regard, the \texttt{acsql} application aims to limit the amount of time and effort required by
instrument analysts to discover and access the data that they need to perform such work.
It should be noted, though, that the \texttt{acsql} application is not limited to this
user base; since the application is non-proprietary, other potential users exist, such as
scientists and researchers external to STScI.

With the nature of ACS instrument work in mind, the \texttt{acsql} application was designed
to acheive four main use cases, each briefly described below.

\textit{Use case 1: Visually inspect an image from the ACS archive}:  The application shall allow
users to view a `Quicklook' JPEG of any publicly-available image in the ACS archive, along with
useful corresponding observational metadata.

\textit{Use case 2: Determine which datasets exist in the ACS archive for a given set of
observational parameters}:  The application shall allow users to determine which 9-character
\texttt{IPPPSSOTT} rootnames exist for a defined set of observational parameters via ACS
header keywords.

\textit{Use case 3: Determine the observational parameters for a given dataset}: The application
shall allow users to determine observational parameters (i.e. FITS header keyword values) for
a given 9-character \texttt{IPPPSSOTT} rootname.

\textit{Use case 4: Programmatically analyze images across custom datasets}: The application
shall allow users to read ACS image data into memory and perform analysis for data obtained
in Use Case (2).


% Related Work
\section{Related Work} \label{chap2}

The main inspiration for the construction of the ACS Quicklook application was derived from the sucess
of a similar application for the Wide Field Camera 3 (WFC3) instrument (also on board HST), known as the
WFC3/Quicklook (\texttt{wfc3ql}) application.  The \texttt{wfc3ql} application shares many of the core
components that \texttt{acsql} does, including a filesystem that stores all WFC3 data on disk, a relational
database that stores WFC3 FITS header information, and a web application for user interactivity with the
system (Bourque et al, 2016).  The \texttt{wfc3ql} has been developed by the WFC3 team at STScI since WFC3
was installed on HST in 2009 during Servicing Mission 4.  The project started out as a single script that
performed a dowload request to MAST for new data, created Quicklook JPEGs from the resulting images, and
saved them to a directory.  Since then, the project has evolved to the filesystem/database/web application stack
that more closely resembles that of \texttt{acsql}.

However, despite the similarites, it should be noted that the implementation of the \texttt{wfc3ql} infrastructure
differs significantly from that of \texttt{acsql} (implementaiton details of the \texttt{acsql} components are
detailed in Chapter N).  For example, unlike the \texttt{acsql} filesystem, which contains only publicly-available data, the
\texttt{wfc3ql} filesystem is essentially a copy of the MAST archive for WFC3.  As such, it contains all data,
including proprietary data which can only be used internally by the WFC3 team at STScI.  Since the \texttt{wfc3ql}
filesystem contains proprietary data, much support is needed in the software to restrict data to certain file
directories, user groups, and file permissions.  Additionally, the \texttt{wfc3ql} database only supports a small subset of
FITS filetypes and extensions, while \texttt{acsql} supports all ACS filetypes and extensions.

Furthermore, with \texttt{wfc3ql} being continuously developed over the past eight years by a team of several developers, there
exist several features in \texttt{wfc3ql} that are not currently implemented on \texttt{acsql}.  For example, the
\texttt{wfc3ql} application supports the daily visual inspection of new WFC3 data, some data of which are proprietary.  Such
a feature is not possible for \texttt{acsql}, as the \texttt{acsql} filesystem is built upon a cache of only publicly-available
data (and thus the project can be considered open-source and non-proprietary).  Secondly, \texttt{wfc3ql} currently contains
several instrument calibration and monitoring routines that are built upon the \texttt{wfc3ql} automation platform/code
library (known as \texttt{pyql}), while \texttt{acsql} has yet to implement any of such routines.  A third example is that
the \texttt{wfc3ql} web application supports the tracking of WFC3 instrument `anomalies' (i.e. anomalous features in images
that should be noted to instrument team members (Gosmeyer, 2017)). These features, amongst others, clearly serve as
possible extensions to the \texttt{acsql} system; such extensions are discussed further in Chapter 5.


% Methodology
\section{Methodology and Implementation} \label{chap3}

In this chapter, we disucss the methods by which we implemented the various subsystems
of the ACS Quicklook system.  Additionally, we discuss the programming standards and
standard workflows that were employed to promote code quality such as readability,
maintainability, extensibility, etc; we believe that this aspect of the project is
at least equaly important to the system as its individual components.


\subsection{Version control} \label{sec3.1}

All code associated with this project (including this paper iteself) is version
controlled using the \texttt{git} Version Control System (VCS) (git, 2017).
The \texttt{git} repository for the project is named \texttt{acsql}.
The \texttt{git} repository is also hosted on \texttt{GitHub}, a repository
hosting service (GitHub, 2017), and is publicly available at
\url{http://github.com/spacetelescope/acsql/}.

Several feature branches of the code were created throughout the building of this project
such that the \texttt{master} branch (which is considered the ``production'' branch)
always contained operational code (while the code in the branches may contain unfinished
implementations).  Such branches include \texttt{create-database} (for implementation of
the database schema), \texttt{add-logging} (for implementation of system logging),
\texttt{build-ingest} (for implementation of data ingestion software), and
\texttt{web-application} (for implementation of the web application).  For each merge of a
feature branch, a \texttt{tag} and \texttt{release} was created for the \texttt{master} branch,
which allows a specific version of the \texttt{master} branch to be saved in the
repository.  These releases are available at
\url{https://github.com/spacetelescope/acsql/releases}.

Additionally, using \texttt{GitHub} allowed for issue tracking of bugs, features, and
potential enhancements to the code repository.  Current open issues of the repository
can be found at \url{https://github.com/spacetelescope/acsql/issues}.


\subsection{Programming and Documentation Standards} \label{sec3.2}

All code contained within this project was written to adhere to specific standards and
conventions, namely (1) the \texttt{PEP8} Style Guide for \texttt{python} code (van Rossum, 2001),
(2) The \texttt{PEP257} \texttt{python} guide for module and function docstring conventions
(Goodger, 2001), and (3) the \texttt{numpydocs} documentation standard (NumPy Documentation,
2017).  More details on each of these standards and conventions are given below.

The \texttt{PEP8} Style Guide for \texttt{python} code (abbreviated for `Python Enhancement
Proposal \#8`) documents \texttt{python} coding conventions including variable naming,
spacing, line length, module layout, function layout, comments, and design patterns.  Only
in specific cases were these conventions not followed, such as using a single line of code,
even if it exceeded the recoomended 80 characters, to allow for greater readability.  By
following these conventions, the style of the \texttt{acsql} code is constistent amongst
each module and attempts to reflect the style of industry-grade \texttt{python} code.

The \texttt{PEP257} guide for docstring conventions describes standard conventions used
for function and module docstrings (i.e. the API documentation found in block
comments at the beginning of modules or immediately after function declarations).  Like
\texttt{PEP8}, following these conventions ensure consistency amongst the \texttt{acsql}
code documentation.  Furthermore, the \texttt{numpydocs} documentation convention provides
some additional details on top of the \texttt{PEP257} conventions and is used in many
\texttt{python} packages including the \texttt{numpy} (numerical \texttt{python}) and
\texttt{scipy} (scientific \texttt{python}) packages (van der Walt et al., 2011).  Figure N
shows an example of these conventions, taken from the
\texttt{ascql.ingest.ingest.get$\_$proposal$\_$type} function.

% Figure for docstring convention example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/docstrings.png}
\caption{An example of the \texttt{PEP257} and \texttt{numpydoc} docstring conventions,
using the \texttt{get$\_$proposal$\_$type} function from \texttt{acsql.ingest.ingest}.}
\label{fig5}
\end{figure}

Another benefit to using \texttt{PEP257} and \texttt{numpydoc} docstring conventions is
that API documentation creation tools such as \texttt{sphinx} (Brandi et al., 2007) or
\texttt{epydoc} (Loper, 2004) can automatically convert the docs into other output
formats such as \texttt{HTML} and \texttt{PDF}.  For this project, we use
\texttt{sphinx} to convert API documentation to \texttt{HTML}, and host the webpages online
using the \texttt{readthedocs}, which is an open-source, community supported tool for
hosting and browing documentation (Read the Docs, 2017). The documentation for
\texttt{acsql} is hosted at \url{http://acsql.readthedocs.io/}.  The output documentation
as seen on \texttt{readthedocs} for the example function in figure N is provided in Figure N.

% Figure for docstring convention example in readthedocs
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/readthedocs.png}
\caption{The \texttt{readthedocs} documentation for the \texttt{acsql} example function
seen in Figure N.}
\label{fig6}
\end{figure}


\subsection{Filesystem: Archive of ACS data} \label{sec3.3}

The \texttt{acsql} filesystem is a Network File System (NFS) that stores all on-orbit
ACS data on disk in an organized set of directories and subdirectories hosted at STScI. Figure N shows
an example of this directory structure: The parent directory is the first four characters
of the 9-character \texttt{rootname}, which maps directly to an individual \texttt{PROPOSID}.
The subdirectories of the parent directories are named after the full 9-character
\texttt{rootname} such that each parent directory contains the \texttt{rootname} subdirectories
that were observed for that particular \texttt{PROPOSID}.  Each \texttt{rootname}
subdirectory contains every available filetype (as described in Section 1.1.4) for the
particular observation is stored.

% Figure for acsql filesystem size over time
\begin{figure}[!t]
\centering
\includegraphics[width=2.0in]{./figures/filesystem_structure.png}
\caption{A representation of the directory structure within the \texttt{acsql} filesystem,
using a few observations as an example.}
\label{fig7}
\end{figure}

Figure N shows how the total size of the filesystem has evolved over the lifetime of the
mission; currently, the filesystem occupies $\sim${40} TB of storage space.  Note that the
file sizes across the detectors and across the various filetypes may vary depending on the
nature of the particular obseration (for example, full-frame observations result in larger
file sizes than subarray observations, calibrated filetypes have larger file sizes than
un-calibrated filetypes, etc.).

% Figure for acsql filesystem size over time
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/filesystem_size.png}
\caption{The size of the \texttt{acsql} filesystem as a function of observation
date.}
\label{fig8}
\end{figure}


\subsection{Filesystem: Archive of JPEGs and Thumbnails} \label{sec3.4}

In addition to the ACS data products described in the last section, the
\texttt{acsql} filesystem also stores ``Quicklook'' \texttt{JPEG} and
\texttt{thumbnail} images of each \texttt{RAW}, \texttt{FLT}, and \texttt{FLC}
filetype (when applicable) in an organized directory structure.  These
images are used by the \texttt{acsql} web application to allow users to
quickly and easily view the contents of the data without having to
pysically open the corresponding \texttt{.fits} files.

The \texttt{JPEG}images are are generated by taking the two-dimensional
data from the \texttt{SCI} extension(s), sigma-clipping the top and bottom
1\% of the values (as to avoid large outlier values and enhance the scaling
of the image), and saving the data to a a \texttt{JPEG} format.  The
\texttt{thumbnail} images are created by simply resizing the corresponding
\texttt{JPEG} into a 128x128 pixel image and saving to a \texttt{.thumb}
extension; the purpose of these \texttt{thumbnail} images are to be able
to view many of them on a single webpage in the \texttt{acsql} web
application.  An example of a \texttt{JPEG} image and its corresponding
\texttt{thumbail} is shown in Figure N.

% Figure for JPEG and thumbnail example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/jpeg_and_thumbnail.png}
\caption{An example of a \texttt{JPEG} image (left) and its corresponding
\texttt{thumbnail} image using example dataset \texttt{jcs718koq}.}
\label{fig9}
\end{figure}

Unlike the ACS data products portion of the filesystem, the \texttt{JPEG}
and \texttt{thumbnail} portions of the filesystem are organized
based on the 5-digit \texttt{PROPOSID} of the corresponding observation
instead of the first four characters of the \texttt{rootname}.  This
design was chosen as a means to simplify the design of the web application;
users often which to view data based on the 5-digit \texttt{PROPOSID} and
less often on the details of the \texttt{rootname}.  An example of this
sturcture is shown in Figure N.  Note that the \texttt{thumbail} filesystem
only contains thumbnails created from \texttt{FLT} filetypes, since thumbnails
are only inteded for navigation and quick-viewing.

% Figure for JPEG and thumnail directory structure
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/jpeg_filesystem.png}
\caption{A representation of the directory structure for the \texttt{JPEG} (left)
and \texttt{thumbail} (right) portion of the \texttt{acsql} filesystem, using a
few observations as an example.}
\label{fig10}
\end{figure}


\subsection{Database: Relational Schema} \label{sec3.5}

Another major component of the \texttt{acsql} project is a relational database
that stores all \texttt{FITS} header key/value pairs for each ACS filetype and
\texttt{FITS} file extension across all on-orbit ACS observations.  Such a
database allows users to perform relational queries for any observational
metadata.

To accomplish this, we implemented the relational schema shown in Figure N.  The
\texttt{acsql} database contains 111 tables in total: one \texttt{master} table
which contains basic information about each \texttt{rootname} that is important
for the \texttt{acsql} database in general, one \texttt{datasets} table which
indicate which filetypes are available for a particular \texttt{rootname}, and
109 `header' tables which stores the header key/value pairs, one for each
\texttt{detector}/\texttt{filetype}/\texttt{extension} combination (e.g.
\texttt{wfc$\_$raw$\_$0}).  Each of these tables are described in detail below.

% Figure for acsql database schema
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/schema.png}
\caption{The relational database schema for the \texttt{acsql} database.}
\label{fig11}
\end{figure}

The \texttt{master} table contains information that is particularly useful
for maintaining and using the \texttt{acsql} database.  Its primary key is
the first 8 characters of the 9-character \texttt{rootname} for the partiuclar
observation (recall from section 1.1.1 that only the first 8 characters of
a \texttt{rootname} are actually unique).  The \texttt{path} column contains
the location of the observation in the \texttt{acsql} filesystem.  The
\texttt{first$\_$ingest$\_$date} and \texttt{last$\_$ingest$\_$date} contains the date
in which the observation was first inserted into the database and the date
in which the observation was most recenly updated in the database, respectively.
The \texttt{last$\_$ingest$\_$date} allows the database maintainer to determine when
data in the database may become outdated and require re-ingestion.

The \texttt{datasets} table lists which filetypes are available for each
observation.  If a particular filetype is available for the given \texttt{rootname},
the value for the appropriate column in the table is the full
\texttt{<rootname>$\_$<filetype>.fits} filename (for example, the \texttt{raw} column
contains the value \texttt{jcs718koq$\_$raw.fits} for \texttt{rootname} \texttt{jcs718ko}).
If a particular filetype is not available, the value of the column is \texttt{NULL}.
This table allows a user to determine which header tables are queryable for a given
\texttt{rootname}.  The \texttt{rootname} in the \texttt{datasets} table acts as both
a primary key for the table as well as a foreign key that maps to the \texttt{rootname}
of the \texttt{master} table.

The remaining 109 tables were designed to be in direct correspondance with the
header metadata key/value pairs found in observations files; each column is named in
the same manner as the header keys, with the value of that column reflecting the header
value. There is one table for each \texttt{detector}, \texttt{filetype},
and \texttt{extension} combination; collectively, these are referred to as the `header'
tables.  Like with the \texttt{datasets} table, the \texttt{rootname} column serves as a
primary key for the header tables as well as a foreign key that maps to the \texttt{rootname}
of the \texttt{master} table.


\subsection{Database: \texttt{MySQL} + \texttt{SQLAlchemy}} \label{sec3.6}

The \texttt{acsql} database is stored on a \texttt{MySQL} server (\texttt{Version 5.6})
(Oracle, 2017) that is hosted at STScI.  The database schema was implimented using
\texttt{SQLAlchemy}, which is an open-source SQL toolkit and Object Relational Mapper (ORM) for
\texttt{python} (Bayer, 2006).  As an ORM, \texttt{SQLAlchemy} enables \texttt{python} classes
to be easily translated to \texttt{SQL}-based database tables, and vice versa.  Additionall,
\texttt{SQLAlchemy} provides \texttt{python} methods for connecting to a SQL-based database and
performing typical \texttt{SQL} tasks such as inserts, updates, and queries.

There are several key functions and classes that were used to construct the \texttt{acsql}
database (all of which can be found in the \texttt{acsql.database.database$\_$interface.py} module).
One such function is the \texttt{load$\_$connection}, as shown in Figure N.  This function creates
three \texttt{SQLAlchemy} objects that are used to establish a connection with the \texttt{acsql}
database: \texttt{engine}, \texttt{base}, and \texttt{session}, each described below.

The \texttt{engine} object contains the Python Database API Specification (also
known as \texttt{DBAPI}), which provides a low-level API for \texttt{python}-specific, commonly-used
database tasks (Lemburg, 2017).  It is created from the \texttt{sqlalchemy.create$\_$engine} method, which
requires a user-supplied \texttt{connection$\_$string}.  The \texttt{connection$\_$string} is a string
that contains information about the type of database, the specific database dialect being used, and
the user credentials (e.g. username, password, port number, and host server name).  In the case
of the \texttt{acsql}, this connection string takes the form of
\texttt{'mysql+pymysql://username:password@host:port/acsql'}.  The \texttt{connection$\_$string} is
imported from a user supplied \texttt{config} file within the \texttt{acsql} library
(as will be discussed in section 3.9).

The \texttt{base} object serves as a base class for declarative class definitions (i.e. the
classes that are used to define the database tables).  It is created from the
\texttt{sqlalchemy.ext.declarative.declatative$\_$base} method.  Perhaps most importantly, the
\texttt{base} object contains methods for creating and dropping tables from the class
definitions (e.g. \texttt{base.metadata.create$\_$all()} and \texttt{base.metadata.drop$\_$all()},
respectively).

The \texttt{session} object provides a primary usage interface for database operations, and
is created via the \texttt{sqlalchemy.sessionmaker} method, which takes as a parameter the
\texttt{engine} object.  The methods of the \texttt{session} object are primarily used to
query the database (i.e. \texttt{session.query()}) as well as commiting inserts or updates (i.e.
\texttt{session.commit()}).

% Figure for load_connection in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/load_connection.png}
\caption{The \texttt{load$\_$conenction} function, which is used to build a connection to the
\texttt{acsql} database}.
\label{fig12}
\end{figure}

The \texttt{master} and \texttt{datasets} tables were implemented via explicit class definitions in
\texttt{database$\_$interface}, and are shown in Figures N and N, respectively.  Each table column is
defined using the \texttt{sqlalchemy.Column} object, which is a class that can be initialized
with the datatype that will be stored in the column (e.g. \texttt{String}, \texttt{Float}, \texttt{Integer},
etc.) as well as parameters that set SQL-like constraints and parameters on the column values.  These
include, but are not limited to, primary keys (e.g. the \texttt{primary$\_$key=True} parameter in the
\texttt{master.rootname} column), foreign key constrains (e.g. the \texttt{ForeignKey} constraint in the
\texttt{datasets.rootname} column), uniqueness constraints (e.g. the \texttt{unique=True} parameters in
the \texttt{master.path} column), and \texttt{NULL} constraints (e.g. the \texttt{nullable=False} parameter
in the \texttt{master.first$\_$ingest$\_$date} column).  \texttt{SQLAlchemy} determines the name of the
table via the \texttt{$\_$$\_$tablename$\_$$\_$} attribute, and determines the name of the columns by
the name of the variable used to initialize each \texttt{Column} object.

% Figure for master table in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/master_table.png}
\caption{The class definition for constructing the \texttt{master} table via \texttt{SQLAlchemy}.}
\label{fig13}
\end{figure}

% Figure for datasets table in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/datasets_table.png}
\caption{The class definition for constructing the \texttt{datasets} table via \texttt{SQLAlchemy}.}
\label{fig14}
\end{figure}

Since there are 109 header tables, some of which have hundreds of columns, it is not practical to construct
a class definition for each table in a similar manner to that of the \texttt{master} and \texttt{datasets}
table.  Instead, these class definitions were implemented via the \texttt{database$\_$interface.orm$\_$factory}
function, which is a factory function that creates and returns a class definition for each header table, based on
the given \texttt{class$\_$name} that reflects the \texttt{detector}/\texttt{filetype}/\texttt{extension} combination
(e.g. \texttt{wfc$\_$raw$\_$0}).  The \texttt{orm$\_$factory} function is shown in Figure N.  Similar to the
\texttt{Master} and \texttt{Datasets} classes, some of the columns in the \texttt{orm$\_$factory} function are
explicitly defined via the \texttt{SQLAlchemy} \texttt{Column} class.  However, the columns that correspond to
header key/value pairs are defined in a separate function named \texttt{define$\_$columns}, shown in Figure N.

% Figure for orm_factory in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/orm_factory.png}
\caption{The \texttt{orm$\_$factory} function, used to define class definitions for header tables.}
\label{fig15}
\end{figure}

% Figure for define_columns in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/define_columns.png}
\caption{The \texttt{define$\_$columns} function, used to define columns used in the header tables.}
\label{fig16}
\end{figure}

The purpose of the \texttt{define$\_$columns} function is to define \texttt{SQAlchemy} \texttt{Column}
objects for each header keyword in the headers of the particular \texttt{detector}/\texttt{filetype}/\texttt{extension}
combination (provided in the given \texttt{class$\_$name} parameter).  This is accomplished by reading in a text
file (named \texttt{<class$\_$name>.txt} that contains the header keywords and their datatype (one per line) for
the given \texttt{class$\_$name}. An portion of an example text file is shown in Figure N.

% Figure for table defintion text file
\begin{figure}[!t]
\centering
\includegraphics[width=0.8in]{./figures/table_definition.png}
\caption{The contents of an example text file used to define the columns of a header table in the
\texttt{define$\_$columns} function. The example table used here is the \texttt{wfc$\_$asn$\_$0} table.}
\label{fig17}
\end{figure}

Furthermore, the 109 text files used to define the header table columns are also generated in an
automated fashion via the \texttt{acsql.database.make$\_$tabledefs.py} module.  This module uses
a set of example FITS files to scrape its header contents, determine all of the header keywords and
their datatypes, and write the results to a text file.  Similarly, the
\texttt{acsql.database.update$\_$tabledefs.py} is used to add new header keywords by comparing the
header contents of a given FITS file and the existing column definition text files\footnote{New header
keywords are occaisonally introduced to ACS data proceeding updates to its calibration software}.

With the implementation of the \texttt{orm$\_$factory} and \texttt{define$\_$columns} function, it is
then trivial to create class definitions for each of the 109 header tables.  An example of this is
shown in Figure N, where the several of the \texttt{WFC} header tables are defined.

% Figure for orm_factory calls
\begin{figure}[!t]
\centering
\includegraphics[width=1.5in]{./figures/orm_factory_calls.png}
\caption{An example of how the \texttt{orm$\_$factory} function is called to create class
defintions for the header tables.}
\label{fig18}
\end{figure}

With the \texttt{master}, \texttt{datasets}, and each of the 109 header tables defined in the
\texttt{database$\_$interface} module, creating the database tables on the \texttt{MySQL} server
is accomplished by executing the \texttt{base.metadata.create$\_$all()} method.


\subsection{Data ingestion software: Algorithm} \label{sec3.7}

Another critical component of the ACS Quicklook system are the modules that are used to ingest
data into the \texttt{acsql} database and to create the ``Quicklook'' JPEGs and thumbails.
By the term `ingest', we refer to the following algorithm:

1. \textbf{\textit{Identify newly available public ACS data in the filesystem:}}  This is accomplished by
comparing the list of \texttt{rootnames} in the filesystem with the list of \texttt{rootnames}
in the \texttt{master} table of the \texttt{acsql} database.  Any \texttt{rootnames} that
exist in the filesystem but not in the database are considered new \texttt{rootnames} to
be ingested.

2. \textbf{\textit{Loop over each \texttt{rootname} (in a parallelized manner):}}  The ingestion
software (i.e. the \texttt{acsql.ingest.ingest} module), takes as input a single
\texttt{rootname}, such that if there are multiple \texttt{rootnames} to be ingested, the
calls to the ingestion module can be parallelized over many CPUs.  The ingestion of one
\texttt{rootname} does not depend on the ingestion of another, nor is the order of which
files are ingested important.  Please note that steps 3 through N are written from the
perspective that a single \texttt{rootname} is being ingested (i.e. inside of the loop.)

3. \textbf{\textit{Update the \texttt{master} table with information about the \texttt{rootname}:}}
At this point, the \texttt{master} table can be updated with metadata pertaining to the
\texttt{rootname}.  A generic \texttt{insert$\_$or$\_$update} function was written
(available in the \texttt{acsql.utils.utils} module) to determine if an entry should be
inserted (in the case of first-time ingestion) or updated (in the case of re-ingestion).
This function uses various \texttt{sqlalchemy} methods and the class definitions described
in section 3.6 to perform the \texttt{insert} or \texttt{update} operation.  The
\texttt{insert$\_$or$\_$update} function is shown in Figure N.

% Figure for insert_or_update
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/insert_or_update.png}
\caption{The \texttt{insert$\_$or$\_$update} function from the \texttt{acsql.utils.utils}
module, used at various times during the data ingestion process to determine if an
entry should be inserted or updated in the \texttt{acsql} database.}
\label{fig19}
\end{figure}

4. \textbf{\textit{Loop over the available \texttt{filetypes} for the given \texttt{rootname}:}}
The available \texttt{filetypes} are determined by traversing down a level in the tree
structure of the filesystem and identifying which files are present. Once determined,
the ingestion algorithm processes each \texttt{<rootname>$\_$<filetype>.fits} file
individually.  Please note that steps 5 through N are written from the perspective that
a single file is being ingested (i.e. inside of the next nested loop).

5. \textbf{\textit{Create a \texttt{python} dictionary with metadata about the file}:}  To reduce
the amount of variables being passed around to various functions, a data container
in the form of a \texttt{python} dictionary data type is created to hold metadata needed
by the remainder of the ingestion process.  We refer to this data container as the
\texttt{file$\_$dict}.  The \texttt{file$\_$dict} contains metadata such as the absolute
path of the file in the filesystem, the \texttt{filetype}, the available FITS file
extensions of the file, and the absolute paths to which the ``Quicklook'' JPEGs and
Thumbnails will be written.

6. \textbf{\textit{For each FITS file exentension, extract the header information and update
the appropriate header table in the \texttt{acsql} database:}}  The header information
is read into a \texttt{python} dictionary via the \texttt{astropy.io.fits} module.
Besides some minor fixes for a few corner cases (such as converting hypens in header keys
to underscores as to avoid \texttt{python} errors), it is rather trivial to perform
and \texttt{insert} or \texttt{update} operation via the \texttt{insert$\_$or$\_$update}
function (see Figure N).

7. \textbf{\textit{Update the \texttt{datasets} table for the given \texttt{filetype}:}}
At this point, an entry in the \texttt{datasets} table is either inserted if it is the
first \texttt{filetype} for the \texttt{rootname} being ingested, or updated if a
\texttt{filetype} under the same \texttt{rootname} had already been ingested.

8. \textbf{\textit{If the \texttt{filetype} is either \texttt{raw}, \texttt{flt}, or
\texttt{flc}, then create a ``Quicklook'' JPEG image:}}  JPEGs are produced only for
\texttt{raw}, \texttt{flt}, and \texttt{flc} \texttt{filetypes}, since it are these
\texttt{filetypes} that contain actual two-dimensional image data.  The image data are
read into multidimensional \texttt{numpy} array data types via the
\texttt{astropy.io.fits} module.  The data are then rescaled as to avoid an undesirable
image stretch caused by extremely high or low-valued pixels, and saved to a \texttt{.jpg}
format.  The JPEGs are saved to the JPEG portion of the \texttt{acsql} filesystem
(described in section 3.4).

9. \textbf{\textit{If the \texttt{filetype} is \texttt{flt}, then create a ``Quicklook''
Thumbnail image:}} Thumbnail images are only produced for \texttt{flt} filetypes since they
are only meant to be viewed as a means to discover the larger JPEG images via the
\texttt{acsql} web application.  Thumbnails are generated by simply opening up the
corresponding \texttt{flt} JPEG and resizing it to 128x128 pixels.  The Thumbnailss are saved
to the Thumbnail portion of the \texttt{acsql} filesystem (described in section 3.4).

This workflow is encapsulated within several modules across the \texttt{acsql.scripts} and
\texttt{acsql.ingest} subpackages, as will be desribed in section 3.9.  These modules are
intended to be executed daily (as an automatically-spawned process) as to keep the ACS
Quicklook system up-to-date on any public data as it becomes available.


\subsection{Data ingestion software: \texttt{logging}} \label{sec3.8}

Since the data ingestion software is intended to be executed by an automatic process and not
by a human, we implemented a system by which the status of the ingestion process can be logged
to an output text file and analyzed at a later time.  Such log files can be used to assess if
there were any issues with the ingestion process, such as if a new header keyword has
appeared (requiring an update to the appropriate header table in the database).  An example log
file showing the ingestion of a single rootname (\texttt{j8zh21xv}) is provided in Figure N.

% Figure for log file
\begin{figure*}[!t]
\centering
\subfloat{\includegraphics[width=7.0in]{./figures/log.png}%
\label{fig_first_case}}
\caption{An example log file for the ingestion of a single file (\texttt{j8zh21xv}).}
\label{fig20}
\end{figure*}

When the ingestion module gets executed, an empty log file is created with the filename
\texttt{<module$\_$name>$\_$<timestamp>.log}, where \texttt{<module$\_$name>} is the name of the
ingestion module (in production, this is \texttt{ingest$\_$production.py}, as will be discussed
in section 3.9), and \texttt{<timestamp>} is the current time in the format \texttt{YYYY-MM-DD-HH-MM}.
The naming convention of the log file allows system maintainers to determine which log file corresponds
to which ingestion run.

Next, the \texttt{python} \texttt{logging} module is used to configure the format of the
log statements.  It does this by (1) setting the default logging \texttt{level} to \texttt{INFO} (meaning
that, unless otherwise specified, each call to \texttt{logging} by the ingestion module will
result in an \texttt{INFO} statement.), (2) setting the timestamp format to \texttt{YYYY-MM-DD HH:MM:SS},
and (3) setting the logging message format to \texttt{<timestamp> <level>: <message>}.

With the logging settings configured, any call to the \texttt{logging} module within the ingestion
software results in a log statement.  For example, the code \texttt{logging.info('Gathering files to
ingest')} results in a timestamped log message, e.g.
\texttt{08/15/2017 11:05:26 INFO: Gathering files to ingest} (as shown in Figure N.)

Calls to the \texttt{logging} module are strategically placed within the ingestion software to provide
enough context to the status of the ingestion without cluttering the log file with too much detail.
In most cases, logging statments only occur after a change of state to the system (i.e. an updated
database table, the creation of a JPEG or Thumbnail.)


\subsection{Web Application} \label{sec3.9}

The front-end of the \texttt{acsql} system is the web application.  The web application is built using
\texttt{Python} and \texttt{Flask}, which is a \texttt{Python} based web framework (Ronacher, 2010).
Currently, the web application has two main features/modes of use: (1) viewing JPEGs and image metadata
for any publicly-available ACS \texttt{raw}, \texttt{flt}, and \texttt{flc} image (when applicible), and
(2) performing relational queries on the \texttt{acsql} database.  To visiualize these features, we show
examples of some of the different webpages that make up the web application in Figures N through N, and
further describe each below.

Figure N shows the \texttt{acsql} homepage.  The homepage, as well as all other webpages in the web
application, contains a menu bar at the top containing four links: (1) to the database query page,
(2) to the archive links page, (3) to the \texttt{acsql} code repository on GitHub, and (4) to the
\texttt{readthedocs} documentation page.  Clicking the ``ACS Quicklook'' button in the menu bar allows
the user to return to the homepage, regadless of which webpage they are currently viewing.  Additionally,
the homepage also contains button-type links to the database query page and the archive links page.

% Figure for homepage
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/homepage.png}
\caption{The homepage of the \texttt{acsql} web application.}
\label{fig21}
\end{figure}

Figure N shows an example of the database query page.  This page allows users to fill out a form that
in turn gets converted to a query of the \texttt{acsql} database and executed when hitting the
`Submit' button at the bottom of the page.  Note that the form contains only a subset of the
many possible database paramters; we limited the database query page to only options that we deemed
to be particularly useful or potentially frequently used by the user.  As such, we expect that this
page to be further expanded and/or modified in the future as more use cases become apparent.

% Figure for database query
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/database_query_page.png}
\caption{A portion of the database query page of the \texttt{acsql} web application.}
\label{fig22}
\end{figure}

In this example, we use the form to find all data that were taken with the \texttt{WFC} detector,
are of Observation Type \texttt{IMAGING}, and were observed by the Principle Investigator Zolt
Levay\footnote{Zolt Levay is a Science Visuals Developer at STScI, and has been the PI of many
programs that have acquired images for HST public releases.}.  Note that there are three output
options: (1) an \texttt{HTML table}, which returns a webpage showing the selected `Output Columns'
(in this case, the Rootname, PI last/first name, Proposal ID, Aperture, Date/Time of observation,
and the Target Name) (see Figure N), (2) a CSV file, which is downloaded to the user's machine,
containing a comma-separated table of the selected output columns (see Figure N), or (3) a webpage
showing the Thumbnail images of all of the resulting images (see Figure N).

% Figure for query results table
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/database_query_results_html.png}
\caption{The results of the database query shown in Figure N in the form of an HTML
table.}
\label{fig23}
\end{figure}

% Figure for query results csv
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/database_query_results_csv.png}
\caption{The results of the database query shown in Figure N in the form of an CSV
file.}
\label{fig24}
\end{figure}

% Figure for query results thumbnails
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/database_query_results_thumbnails.png}
\caption{The results of the database query shown in Figure N in the form of thumbnail
images.}
\label{fig25}
\end{figure}

Figure N shows the archive links page.  This page contains links to every proposal that contains
publicly availble ACS data via the 4-5 digit \texttt{PROPOSID}.  Clicking one of the links
opens a new window to a `view proposal' webpage (see Figure N).  Similar to the database query
results shown in Figure N, the `view proposal' webpage shows thumbnail images of every ACS
dataset available in the given proposal.  The `view proposal' pages contain several buttons and
filters near the top of the page; using these will sort and/or filter out the thumbnail images
based on the chosen paramters.  Figure N shows an example of this webpage, using proposal 14039.

% Figure for archive links
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/archive_links.png}
\caption{The archive links webpage of the \texttt{acsql} web application.}
\label{fig26}
\end{figure}

% Figure for view proposal
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/view_proposal.png}
\caption{An example of a `view proposal' webpage, using proposal 14039.}
\label{fig27}
\end{figure}

In the `view proposal' webpages, users may click on any one of the thumbnail images to bring up
the `view image' webpage for that particular image.  An example of this webpage is shown in Figure
N, using the dataset \texttt{jcs718kmq}.  This webpage contains the ``Quicklook'' JPEG of the image
along with useful metadata of the dataset near the top of the page.  It also contains an additional link
(\texttt{proposal}) to view the other images within the particular proposal via the appropriate
`view proposal' webpage.

% Figure for view image
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/view_image.png}
\caption{An example of a `view image' webpage, using dataset \texttt{jcs718kmq}.}
\label{fig28}
\end{figure}

\subsubsection{Implementation}

The web application is implemented by several \texttt{Python} modules, namely:

\begin{itemize}
\item \texttt{acsql$\_$webapp.py}
\item \texttt{data$\_$containers.py}
\item \texttt{form$\_$options.py}
\item \texttt{query$\_$form.py}
\item \texttt{query$\_$lib.py}
\end{itemize}

as well as several subdirectories containing useful static files and templates, namely:

\begin{itemize}
\item \texttt{static/css/*.css}
\item \texttt{static/js/*.js}
\item \texttt{static/img/*}
\item \texttt{templates/*.html}
\end{itemize}

Below we further describe these modules, directories, and files, and how they relate to each other.

The \texttt{acsql$\_$webapp} module is the main module for running the \texttt{acsql} web application;
it is this module that must be executed in order to serve the web application (either on a dedicated
web server, or locally on a user's machine, accessed through the user's \texttt{localhost}).  This module
uses the \texttt{Flask} web framework to receive incoming \texttt{HTML} requests.  It is structured such
that each \texttt{acsql} webpage relates to an individual function within \texttt{acsql$\_$webapp} (for
example, accessing the \texttt{/archive/} webpage results in the execution of the \texttt{archive} function).
Each of these functions contain the appropriate \texttt{Python} logic and rendering of \texttt{HTML} templates
to return the desired webpage.

Much of the functionality required to gather data needed for the various \texttt{acsql} webpages (e.g. lists
of images, image metadata, paths to JPEG images on disk, etc.) is imported into \texttt{acsql$\_$webapp} from
the \texttt{data$\_$containers.py} module.  That is to say, many of the functions within the
\texttt{acsql$\_$webapp} module calls functions from \texttt{data$\_$containers} to gather data to eventually
pass on to the \texttt{HTML} template.  This design choice was made in order to separate the data from the
functionality, which is often regarded as a best practice in software engineering.

Along those same lines, the \texttt{form$\_$options.py} module is simply a container module for storing
the possible form options (e.g. apertures, filters, output column, proposal types, etc.) for the database query
form page.  These data could have been defined within the \texttt{acsql$\_$webapp} module, but we chose to
separate out these data.

The \texttt{query$\_$form.py} and \texttt{query$\_$lib.py} modules are used extensively to render the
database query webpage and convert a completed form into an executable query on the \texttt{acsql} database,
respectively.  The \texttt{query$\_$form} module contains several class objects for supplying specific types
of form fields (e.g. check box fields, text fields, multiple select fields) as well as functions that validate
form entries.  Several of the form objects are extensions of components (via subclassing) provided by the
\texttt{wtforms} library, which is a form validation and rednering library for \texttt{Python} web development
(wtforms).  The {query$\_$lib} module contains functions that parse, build, validate, and return \texttt{SQLAlchemy}
\texttt{query} objects from the results of a submitted database query form.  These queries are then executed
on the \texttt{acsql} database and results are used to render the database query result HTML, CSV, and/or Thumbnail
webpages.

Like many web applications, we also store static files such as \texttt{HTML} templates, \texttt{CSS} templates, and static
images in separate \texttt{static/} and \texttt{templates/} directories.  The \texttt{static/css/} directory
contains the \texttt{CSS} templates used in the \texttt{HTML} templates.  Similarly, the \texttt{static/js/} directory
contains several \texttt{JavaScript} libraries, also used in the \texttt{HTML} templates. Lastly, the \texttt{templates/}
directory contains the \texttt{HTML} templates used to render the various webpages of the web application.  There is one
template for each webpage, as well as a template that houses \texttt{HTML} that is common to each webpage (e.g. the
menu bar), named \texttt{base.html}. Aside from some minor tweaks, we use templates from \texttt{Bootstrap}, which is a
front-end component library and open source toolkit for developing \texttt{HTML}, \texttt{CSS}, and \texttt{JS} (bootstrap).


\subsection{\texttt{acsql} Package} \label{sec3.10}

All code associated with the \texttt{acsql} project is contained within a single \texttt{git} repository
(also named \texttt{acsql}), which we refer to as the ``\texttt{acsql} Library'', or ``\texttt{acsql} package''.
The package layout is shown below:

\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}
\begin{lstlisting}
acsql/
    LICENSE
    README.md
    MANIFEST.in
    setup.py
    paper/
        ...
    presentation/
        ...
    docs/
        Makefile
        requirements.rst
        source/
          conf.py
          database.rst
          index.rst
          ingest.rst
          scripts.rst
          utils.rst
          website.rst
    acsql/
        __init__.py
        database/
            __init__.py
            database_interface.py
            make_tabledefs.py
            queries.py
            reset_database.py
            table_definitions/
                *.txt
            update_tabledefs.py
        ingest/
            __init__.py
            ingest.py
            make_file_dict.py
            make_jpeg.py
            make_thumbnail.py
        scripts/
            __init__.py
            ingest_production.py
        utils/
            __init__.py
            config.yaml
            utils.py
        website/
            __init__.py
            acsql_webapp.py
            data_containers.py
            form_options.py
            query_form.py
            query_lib.py
            static/
                css/
                    *.css
                img/
                    jpegs
                    thumbnails
                js/
                    *.js
            templates/
                *.html
\end{lstlisting}

We now provide a brief description of each package component:\\

\noindent\texttt{LICENSE}: A BSD 3-Clause license, which states that the \texttt{acsql} package is an open source software package
and may be used and redistributed.\\

\noindent\texttt{README.md}: A \texttt{README} file that describes how to install and use the \texttt{acsql} package.\\

\noindent\texttt{MANIFEST.in}: A list of static files to be included in the tarball file when the user installs the
\noindent\texttt{acsql} package.\\

\noindent\texttt{setup.py}: The \texttt{acsql} package installtion script.  Executing this script with \texttt{python setup.py install}
installs the package into the software environment.\\

\noindent\texttt{paper/}: A subdirectory which contains all materials used for the creation of this paper.\\

\noindent\texttt{presentation/}: A subdirectory which contains all materials used for the creation of the COSC 880 presentation.\\

\noindent\texttt{docs/}: A subdirectory which contains all materials used for the creation of the \texttt{sphinx} API docuemntation
hosted on Read the Docs (see Section 3.2).\\

\noindent\texttt{Makefile}: A \texttt{make} script that is used to build the \texttt{sphinx} API docuemntation from the source
reStructured Text files (see below) (see Section 3.2).\\

\noindent\texttt{requirements.rst}: A list of \texttt{acsql} package dependencies, used by Read the Docs to build a virtual
machine that constructs the resulting \texttt{html} doc pages (see Section 3.2).\\

\noindent\texttt{source/}: A subdirectory that contains all of the reStructured Text files used for building the \texttt{sphinx}
API docuemntation, one \texttt{.rst} file per subpackage, including a master \texttt{index.rst} file (see Section 3.2).\\

\noindent\texttt{acsql/}: A subdirectory that contains all \texttt{Python} code that is part of the official \texttt{acsql} Library.
This is the top level of the importable \texttt{acsql} package.\\

\noindent\texttt{$\_$$\_$init$\_$$\_$.py}: A \texttt{Python} file that indicates that the subdirectory is part of the overall
\texttt{acsql} package.\\

\noindent\texttt{database/}: The \texttt{database} subpackage, containing \texttt{Python} modules that pertain to the \texttt{acsql}
database (see Sections 3.5 and 3.6).\\

\noindent\texttt{database$\_$interface.py}: The \texttt{Python} module for constructing and connecting to the \texttt{acsql} database
(see Section 3.6). \\

\noindent\texttt{make$\_$tabledefs.py}: The \texttt{Python} module for creating the table definition text files (see Section 3.6) \\

\noindent\texttt{queries.py}: A \texttt{Python} module that contains several examples of queries that can be used with the
\texttt{acsql} database.\\

\noindent\texttt{reset$\_$database.py}: A \texttt{Python} module that allows the user to `reset' the \texttt{acsql} database (i.e.
drop all tables, then create all tables).\\

\noindent\texttt{table$\_$definitions}: A subdirectory containing all of the \texttt{<detector>$\_$<filetype>$\_$<extension>} text files,
each of which contain a list of header keys along with their datatypes (see Section 3.6).\\

\noindent\texttt{update$\_$tabledefs.py}: A \texttt{Python} module that allows the user to update the \texttt{table$\_$definitions}
text files with new header keywords (see Section 3.6).\\

\noindent\texttt{ingest/}: The \texttt{ingest} subpackage, containing \texttt{Python} modules for ingesting new data into the
\texttt{acsql} system, including database updates and the creation of JPEGs/Thumbnails (see Section 3.7).\\

\noindent\texttt{ingest.py}: A \texttt{Python} module for performing the ingestion of a single file (see Section 4.7).\\

\noindent\texttt{make$\_$file$\_$dict.py}: A \texttt{Python} module for creating a \texttt{file$\_$dict} for an individual file
(see Section 3.7).\\

\noindent\texttt{make$\_$jpeg.py}: A \texttt{Python} module for creating a JPEG image from an individal file (see Section 3.7).\\

\noindent\texttt{make$\_$thumbnail.py}: A \texttt{Python} module for creating a Thumbnail image from an individal JPEG (see Section 3.7).\\

\noindent\texttt{scripts/}: The \texttt{scripts} subpackage, containing \texttt{Python} modules for ingesting multiple files from
the \texttt{acsql} filesystem, as well as storage place for possible future instrument calibration and monitoring routines. \\

\noindent\texttt{ingest$\_$production}: The \texttt{Python} module for ingesting new ACS data as it becomes publicly available, intended
to be executed periodically.\\

\noindent\texttt{utils/}: The \texttt{utils} subpackage, containing \texttt{Python} modules that are useful for general \texttt{acsql}
operations (e.g. configuring \texttt{loggging}, supplying hard-coded instrument configurations, etc.) as well as a configuration file
for storing sensitive credentials and directory locations.\\

\noindent\texttt{config.yaml}: A text file containing hard-coded user-specific directory locations and \texttt{acsql} database
credentials.  Specifially, it contains values for the \texttt{acsql} database \texttt{connection$\_$string}, as well as locations for
the \texttt{filesystem}, \texttt{log$\_$dir}, \texttt{jpeg$\_$dir}, and \texttt{thumbnail$\_$dir}.  The contents of the \texttt{config.yaml}
file can be imported via the \texttt{utils.utils.SETTINGS} dictionary.\\

\noindent\texttt{utils.py}: A \texttt{Python} module containing various functions that are generally useful for \texttt{acsql} operations,
such as configuring logging, determining if a database entry requires an \texttt{insert} or an \texttt{update}, and hard-coded \texttt{Python}
variables that reflect instrument/system configurations.\\

\noindent\texttt{website/}: The \texttt{website} subpackage, containing \texttt{Python} modules that are used in the construction and
operations of the \texttt{acsql} web application (see Section 3.9).\\

\noindent\texttt{acsql$\_$webapp.py}: The main \texttt{Python} module for running the \texttt{acsql} web application, using the \texttt{Python}
\texttt{Flask} web framework (see Section 3.9).\\

\noindent\texttt{data$\_$containers.py}: The \texttt{Python} module that contains various functions for reterning various data to be used
by the \texttt{acsql} web application (see Section 3.9).\\

\noindent\texttt{form$\_$options.py}: A \texttt{Python} module that stores form data for the database query portion of the \texttt{acsql}
web application (see Section 3.9)\\

\noindent\texttt{query$\_$form.py}: A \texttt{Python} module that contains class objects for building the query form for the database
query portion of the \texttt{acsql} web application (see Section 3.9)\\

\noindent\texttt{query$\_$lib.py}: A \texttt{Python} module that contains various functions to support the querying of the \texttt{acsql}
databse through the \texttt{acsql} web application (see Section 3.9).\\

\noindent\texttt{static/}: A subdirectory containing static materials used by the \texttt{acsql} web application, such as \texttt{CSS}
templates (i.e. \texttt{css/}, \texttt{JavaScript} functions (i.e. \texttt{js/}, and symbolic links to the JPEGs and Thumbnails hosted
on the web application (i.e. \texttt{img/} (see Section 3.9).\\

\noindent\texttt{templates/}: A subdirectory containing \texttt{HTML} templates used to render the various webpages of the \texttt{acsql}
web application, one for each page (see Section 3.9).\\

For further details on each \texttt{Python} module within the \texttt{acsql} package, readers are encouraged to view the official
API documentation hosted at \url{http://acsql.readthedocs.io/}.


% Results
\section{Results} \label{chap4}

The results of the system implementation (described in Chapter 2) were several project deliverables (each described further in the
sections below:

\begin{enumerate}
\item Filesystem
\item Database
\item Web application
\item Software package
\item Software documenation
\end{enumerate}


The project deliverables will primarily be used by members of the ACS instrument team at STScI, but may also be used
by ACS users external to STScI.

\subsection{Filesystem Deliverable} \label{sec4.1}

As described in Sections 3.3 and 3.4, the \texttt{acsql} filesystem is comprised of two major parts: (1) A filesystem
that stores the archive of publicly-available ACS data (i.e. the FITS files), and (2) a filesystem of ``Quicklook''
JPEGs and Thumbnails.

For the former, we utilzed an already-existing filesystem of ACS data internal to STScI known as the ``MAST public cache'';
this filesystem is organized in a very similar way to that shown in Figure N\footnote{We omit the mention of the parent
directory structure and server names here as well as in the \texttt{acsql} code repository as to avoid exposing possible
sensitive information.}.  Though this service is internal to STScI, it is possible for an external user to reconstruct the
filesystem, as all data within the MAST public cache is publically available to download via the MAST archive (i.e.
\url{https://archive.stsci.edu/}).  The location of the filesystem is determined by the \texttt{filesystem} parameter in
the user-supplied \texttt{config.yaml} file (see Section 3.10).

Currently, the filesystem consists of $\sim$1,030,000 total files. Figure N shows how this breaks down by individual
filetype.  We see that \texttt{spt}, \texttt{raw}, and \texttt{flt} make up the majority of the files, which is not surprising
considering that these filetypes occurr for nearly every observing mode.  On the other hand, we see a small amount of
\texttt{crj} and \texttt{crc} files, which is also unsurprising considering that these filetypes are only triggered for
specific observing modes.

% Figure for number of images per filetype
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/num_files_by_filetype.png}
\caption{The number of files in the \texttt{acsql} filesystem by filetype.}
\label{fig29}
\end{figure}

As per item (2), the filesystem of JPEGs and Thumbnails was constructed during the ingestion of all publicly-available
ACS data (via \texttt{ingest$\_$production.py}, see section 3.10).  The location of the JPEG/Thumbnail filesystem is determined
by the \texttt{jpeg$\_$dir} and \texttt{thumbnail$\_$dir} parameters in the \texttt{config.yaml} file, respectively.
Currently, there are $\sim$457,000 JPEGS and $\sim$185,000 corresponding Thumbnail images in the filesystem\footnote{recall that Thumbnail
images are only generated for \texttt{flt} filetypes, hence the descrepency in number}.


\subsection{Database Deliverable} \label{sec4.2}

As described in Sections 3.5 and 3.6, the \texttt{acsql} database is a \texttt{MySQL} database that stores the header
information of every public ACS dataset.  Currently, this database is hosted on a server that is internal to STScI.  However,
external users may build their own copy of the database via the \texttt{ingest$\_$production.py} and \texttt{database$\_$interface}
modules.  All 111 tables of \texttt{acsql} database are up to date as of the time of this writing (September 2017), and it is
intended that the database will be kept up-to-date via periodic executions of \texttt{ingest$\_$production.py}.

Figure N shows the number of records in each table of the database.  Currently, there are $\sim$4,300,000 records in total amongst
the 111 tables.

% Figure for number of records per table
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/database_records.png}
\caption{The number of records in each of the \texttt{acsql} database tables.}
\label{fig30}
\end{figure}


\subsection{Web Application Deliverable} \label{sec4.3}

As described in Section 3.9, the \texttt{acsql} web application consists of a series of \texttt{Python} modules
and static files.  Currently, the web application is not yet hosted on a dedicated web server (neither externally nor
internally to STScI\footnote{At the time of this writing, work is being done to build an web server that
is internal to STScI to allow ACS instrument team members to more easily access the \texttt{acsql} web
application.  We expect this web server to be operation within the next few months.}), however, users can
operate the application through the user's \texttt{localhost}.  Detailed installation and operation
instructions for the web application are provided in the official documentation (see Section 3.2).  In short,
users must (1) ensure that they have built (or have access to) the \texttt{acsql} filesystem and database,
(2) have installed the \texttt{Python} package dependencies, and (3) have filled out the \texttt{config.yaml}
file (see Section 3.10).


\subsection{Software Package Deliverable} \label{sec4.4}

As described in Sections 3.1 and 3.10, the \texttt{acsql} git repository serves as the software package that contains
all of the code and supporting materials needed to operate the \texttt{acsql} system.  The software package is open-source,
and is avilable to download directly from the \texttt{GitHub} repository (\url{http://github.com/acsql/}).  All
future enhancements and bug fixes to the \texttt{acsql} project will occur through this version-controlled repository.


\subsection{Software Documentation Deliverable} \label{sec4.5}

As described in Section 3.2, another deliverable for the project is the API documentation that is automatically
generated via \texttt{sphinx}.  The resulting \texttt{HTML} pages are available through the \texttt{acsql} package,
but are also hosted on \texttt{readthedocs}, available at \url{http://acsql.readthedocs.io/}.  This is considered
the official code documentation.


% Discussion
\section{Discussion} \label{chap5}

\subsection{Possible enhancements to the \texttt{acsql} system} \label{sec5.1}

Though these currently are the only
two main features, we expect that the web application may be a source of significant ongoing development,
as the number of possible features implemented on top of the \texttt{acsql} database and \texttt{acsql}
filesystem are plentiful.

\subsection{Possible simplifications based on MAST archive} \label{sec5.2}

\subsection{Possible extensions to other instruments or missions} \label{sec5.3}


% Conclusion
\section{Conclusion} \label{chap6}
The conclusion goes here.


% use section* for acknowledgment
\ifCLASSOPTIONcompsoc
  \section*{Acknowledgments}
\else
  \section*{Acknowledgment}
\fi
  The authors would like to thanks various members of the STScI staff that were extremely valuable for helping make
  this project come together: members of the WFC3/Quicklook team, for their years of ongoing development and support
  of the WFC3/Quicklook project, without which there would be no inspiration to create this similar project (Varun Bajaj,
  Ariel Bowers, Michael Dulue, Meredith Durbin, Jules Fowler, Catherine Gosmeyer, Heather Gunning, Harish Khandrika,
  Catherine Martlin, Abhi Rajan, Clare Shanahan, Ben Sunnquist, Alex Viana); members of the Instruments Division,
  who support the creation and maintenance of an internal web server (Francesca Boffi, Norman Grogin); Members of the
  Information Technology and Services Division who provided valuable resources such as the database server and disk
  space used to store project materials; and finally, Named Person, who provided insightful comments and suggestions
  on this document.


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


% Referecnes
\begin{thebibliography}{1}

\bibitem{IEEEhowto:sm3b}
\emph{SM3B}, National Aeronautics and Space Administration, Goddard Space Flight Center,
[Online; accessed 2017-09-16], available at \url{https://asd.gsfc.nasa.gov/archive/hubble/missions/sm3b.html}.

\bibitem{IEEEhowto:sm4}
\emph{SM4}, National Aeronautics and Space Administration, Goddard Space Flight Center,
[Online; accessed 2017-09-16], available at \url{https://asd.gsfc.nasa.gov/archive/hubble/missions/sm4.html}.

\bibitem{IEEEhowto:avila}
Avila, R., et al., 2017, \emph{ACS Instrument Handbook}, Version 16.0 (Baltimore: STScI)

\bibitem{IEEEhowto:mast}
\emph{The Barbara A. Mikulski Archive for Space Telescopes}, [Online; accessed 2017-07-30],
available at \url{https://archive.stsci.edu/}.

\bibitem{IEEEhowto:fits}
\emph{Definition of the Flexible Image Transport System (FITS): The FITS Standard}, 2008,
International Astronomical Union FITS Working Group, available at
\url{https://fits.gsfc.nasa.gov/standard30/fits_standard30aa.pdf}.

\bibitem{IEEEhowto:stsci}
\emph{STScI: Space Telescope Science Institute}, [Online; accessed 2017-09-16], available at \url{www.stsci.edu}.

\bibitem{IEEEhowto:smith}
Smith, E., et al., 2011, \emph{Introduction to the HST Data Handbooks}, Version 8.0 (Baltimore: STScI)

\bibitem{IEEEhowto:lucas}
Lucas, R. A., et al., 2016, \emph{ACS Data Handbook}, Version 8.0 (Baltimore: STScI)








\bibitem{IEEEhowto:robitaille}
Robitaille, T.P., et al., 2013, \emph{Astropy: A community Python package for astronomy},
Astronomy \& Astrophysics, 558, A33.










\bibitem{IEEEhowto:numpydoc}
\emph{A Guide to NumPy/SciPy Documentation}, [Online; accessed 2017-08-05], available at
\url{https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt}

\bibitem{IEEEhowto:bayer}
Bayer, M., 2006, \emph{SQLAlchemy: The database toolkit for Python}, [Online; accessed 2017-02-21],
available at \url{http://www.sqlalchemy.org/}.

\bibitem{IEEEhowto:bootstrap}
\emph{Bootstrap}, [Online; accessed 2017-09-04], available at \url{http://getbootstrap.com/}.

\bibitem{IEEEhowto:bourque_adass}
Bourque, M., et al., 2016, \emph{The Hubble Space Telescope Wide Field Camera 3 Quicklook Project},
Astronomical Data Analysis Software $\&$ Systems Conference Proceedings, ADASS XXVI, ASP-CS, submitted

\bibitem{IEEEhowto:bourque_astroinformatics}
Bourque, M., et al., 2016, \emph{The HST/WFC3 Quicklook Project: A User Interface to Hubble
Space Telescope Wide Field Camera 3 Data}, Proceedings IAU Symposium No. 325, 2016, Astroinformatics.

\bibitem{IEEEhowto:brandi}
Brandi, G., et al., 2007, \emph{Sphinx: Python Documentation Generator}, available at
\url{http://www.sphinx-doc.org/en/stable/}.







\bibitem{IEEEhowto:git}
\emph{git}, [Online; accessed 2017-08-05], available at \url{https://git-scm.com}.

\bibitem{IEEEhowto:github}
\emph{GitHub}, [Online; accessed 2017-08-05], available at \url{https:/github.com}.

\bibitem{IEEEhowto:goodger}
Goodger, D., 2001, \emph{PEP 257 -- Docstring Conventions}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0257/}.

\bibitem{IEEEhowto:lemburg}
Lemburg, M., 2017, \emph{PEP 249 -- Python Database API Specification v2.0}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0249/}.

\bibitem{IEEEhowto:loper}
Loper, E., 2004, \emph{Epydoc: Generating API Documentation in Python}, Proceedings of the
Second Annual Python Conference, available at \url{http://epydoc.sourceforge.net/}.

\bibitem{IEEEhowto:oracle}
\emph{MySQL 5.6 Reference Manual}, Oracle, [Online; accessed 2017-08-13], available at
\url{https://dev.mysql.com/doc/refman/5.6/en/}

\bibitem{IEEEhowto:readthedocs}
\emph{Read the Docs}, [Online; accessed 2017-08-05], available at \url{https://readthedocs.org}.

\bibitem{IEEEhowto:ronacher}
Ronacher, A., et al., 2010, [Online; accessed 2017-09-04], available at \url{http://flask.pocoo.org/}


\bibitem{IEEEhowto:mast_portal}
\emph{The MAST Portal}, [Online; accessed 2017-09-15], available at \url{https://mast.stsci.edu/}

\bibitem{IEEEhowto:vanDerWalt}
van der Walt, S., Colbert, C., and Varoquaux, G., 2011, \emph{The NumPy Array: A Structure for
Efficient Numerical Computation}, Computing in Science \& Engineering, 13, 22-30.

\bibitem{IEEEhowto:vanRossum}
van Rossum, G., 2001, \emph{PEP 8 -- Style Guide for Python Code}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0008/}.

\bibitem{IEEEhowto:wtforms}
\emph{wtforms}, [Online; accessed 2017-09-04], available at \url{https://github.com/wtforms/wtforms/}.

\end{thebibliography}

% Appendices
\onecolumn
\newpage
\appendices
\section{\texttt{acsql} Code}

Table of contents.

\noindent\textbf{\texttt{LICENSE}}\lstset{style=code}\lstinputlisting{../LICENSE}
\textbf{\texttt{README.md}}\lstset{style=code}\lstinputlisting{../README.md}
\textbf{\texttt{MANIFEST.in}}\lstset{style=code}\lstinputlisting{../MANIFEST.in}
\textbf{\texttt{setup.py}}\lstset{style=code}\lstinputlisting[language=Python]{../setup.py}
\textbf{\texttt{docs.Makefile}}\lstset{style=code}\lstinputlisting{../docs/Makefile}
\textbf{\texttt{docs/requirements.txt}}\lstset{style=code}\lstinputlisting{../docs/requirements.txt}
\newpage
\textbf{\texttt{docs/source/conf.py}}\lstset{style=code}\lstinputlisting[language=Python]{../docs/source/conf.py}
\textbf{\texttt{docs/source/database.rst}}\lstset{style=code}\lstinputlisting{../docs/source/database.rst}
\textbf{\texttt{docs/source/index.rst}}\lstset{style=code}\lstinputlisting{../docs/source/index.rst}
\textbf{\texttt{docs/source/ingest.rst}}\lstset{style=code}\lstinputlisting{../docs/source/ingest.rst}
\textbf{\texttt{docs/source/scripts.rst}}\lstset{style=code}\lstinputlisting{../docs/source/scripts.rst}
\textbf{\texttt{docs/source/utils.rst}}\lstset{style=code}\lstinputlisting{../docs/source/utils.rst}
\textbf{\texttt{docs/source/website.rst}}\lstset{style=code}\lstinputlisting{../docs/source/website.rst}
\textbf{\texttt{acsql/database/database$\_$interface.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/database/database_interface.py}
\textbf{\texttt{acsql/database/make$\_$tabledefs.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/database/make_tabledefs.py}
\textbf{\texttt{acsql/database/queries.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/database/queries.py}
\textbf{\texttt{acsql/database/reset$\_$database.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/database/reset_database.py}
\textbf{\texttt{acsql/database/update$\_$tabledefs.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/database/update_tabledefs.py}
\textbf{\texttt{acsql/ingest/ingest.py}\lstset{style=code}}\lstinputlisting[language=Python]{../acsql/ingest/ingest.py}
\textbf{\texttt{acsql/ingest/make$\_$file$\_$dict.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/ingest/make_file_dict.py}
\textbf{\texttt{acsql/ingest/make$\_$jpeg.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/ingest/make_jpeg.py}
\textbf{\texttt{acsql/ingest/make$\_$thumbnail.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/ingest/make_thumbnail.py}
\newpage
\textbf{\texttt{acsql/scripts/ingest$\_$production.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/scripts/ingest_production.py}
\textbf{\texttt{acsql/utils/utils.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/utils/utils.py}
\textbf{\texttt{acsql/website/acsql$\_$webapp.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/website/acsql_webapp.py}
\textbf{\texttt{acsql/website/data$\_$containers.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/website/data_containers.py}
\textbf{\texttt{acsql/website/form$\_$options.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/website/form_options.py}
\textbf{\texttt{acsql/website/query$\_$form.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/website/query_form.py}
\textbf{\texttt{acsql/website/query$\_$lib.py}}\lstset{style=code}\lstinputlisting[language=Python]{../acsql/website/query_lib.py}
\textbf{\texttt{acsql/website/templates/404.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/404.html}
\textbf{\texttt{acsql/website/templates/500.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/500.html}
\textbf{\texttt{acsql/website/templates/$\_$formhelpers.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/_formhelpers.html}
\textbf{\texttt{acsql/website/templates/archive.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/archive.html}
\textbf{\texttt{acsql/website/templates/base.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/base.html}
\textbf{\texttt{acsql/website/templates/database.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/database.html}
\textbf{\texttt{acsql/website/templates/database$\_$error.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/database_error.html}
\textbf{\texttt{acsql/website/templates/database$\_$table.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/database_table.html}
\textbf{\texttt{acsql/website/templates/header.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/header.html}
\textbf{\texttt{acsql/website/templates/index.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/index.html}
\textbf{\texttt{acsql/website/templates/view$\_$image.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/view_image.html}
\textbf{\texttt{acsql/website/templates/view$\_$proposal.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/view_proposal.html}
\textbf{\texttt{acsql/website/templates/view$\_$query$\_$results.html}}\lstset{style=code}\lstinputlisting[language=HTML]{../acsql/website/templates/view_query_results.html}


\end{document}
