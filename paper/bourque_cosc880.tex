%% bourque_cosc880.tex
%% Matthew Bourque

\documentclass[10pt,journal,compsoc]{IEEEtran}

% imports
\usepackage{color}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}

% *** CITATION RELATED PACKAGES ***
\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% Colors
\definecolor{gray}{gray}{0.85}


\begin{document}

% Title
\title{The Hubble Space Telescope (HST) Advanced Camera for Surveys (ACS) Quicklook Project}

% Authors
\author{Matthew~Bourque[1], Sara~Ogaz[1], Alex~Viana[2], Meredith~Durbin[3], Norman Grogin[1]\\
\begin{flushleft}
{\scriptsize [1] Space Telescope Science Institute, Baltimore, Maryland 21218. email: bourque@stsci.edu, ogaz@stsci.edu, grogin@stsci.edu}\\
{\scriptsize [2] Dept. of Astronomy, The University of Washington, Box 351580, U.W. Seattle, Washington, 98195, email:mdurbin@uw.edu}\\
{\scriptsize [3] Terbium Labs, Baltimore, Maryland 21201. email: alexcostaviana@gmail.com}
\end{flushleft}
\thanks{Manuscript received Month DD, YYYY}}

% Abstract
\IEEEtitleabstractindextext{%
\begin{abstract}
What is an abstract, really?
\end{abstract}}


% make the title area
\maketitle
\IEEEdisplaynontitleabstractindextext
\IEEEpeerreviewmaketitle


% Introduction
\IEEEraisesectionheading{\section{Introduction}\label{sec:introduction}}
The Advanced Camera for Surveys (ACS) is a third-generation imaging
instrument on board the Hubble Space Telescope (HST), installed in 2002 during
Servicing Mission 3B. It is comprised of three detectors: (1) the Wide Field Camera
(WFC), which is designed for wide-field imaging and spectroscopy in visible to
near-infrared wavelengths, (2) the High Resolution Channel, which is designed for
high resolution near-ultraviolet to near-infrared wavelength images and coronography,
and (3) the Solar Blind Channel (SBC), desingned for far-ultraviolet imaging and
spectroscopy.  ACS expererienced an electronics failure in 2007 that affected
the WFC and HRC detectors, until 2009 when astronauts succesfully restored the WFC
detector during Servicing Mission 4; the HRC still remains unoperational.

Besides these few hiccups, the ACS instrument has been steadily acquiring astronomical
images over its 15 on-orbit lifetime.  Figure 1 shows an estimates of the number of
observations over time for each of the three detectors.  To date, there have been
nearly 200,000 of observations total.  Further information about the ACS instrument
including its history, configuration, performance, and scientific capability can be
found in the ACS Instrument Handbook (Avila et al., 2017).

% Figure for ACS observations over time
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/num_obs.png}
\caption{The number of observations over time for each of the three detectors on ACS.}
\label{fig1}
\end{figure}

ACS data, along with all other data from the other HST instruments past and present
(e.g. The Wide Field Camera 3 (WFC3), The Cosmic Origins Spectrography (COS), etc.),
are primarily stored and publicly-available in the Barbara A. Mikulski Archive for
Space Telescopes (MAST)\footnote{named after the U.S. Senator from Maryland who has
been a pivitol political driving force behind the manned servicing missions, the
Hubble Space Telescope, and the forthcoming James Webb Space Telescope} (Barbara, 2017).
Through MAST, users can request and retreive data for any publicly-available dataset
via \texttt{ftp}, \texttt{sftp}, or DVD by mail\footnote{Not all HST data are publicly
available; most HST data of scientific targets are considered proprietary for up to
one calendar year, after which they are publicly released.}.  The ACS data, like most all other
astronomical data, are stored in the Flexible Image Transport System (FITS) filetype
(FITS, 2008).  This filetype has several unique characteristics, as will be
discuessed in section 1.1.

The ACS Quicklook Project is a \texttt{python}-based application for discovering,
viewing, and querying all publicly-available ACS data.  It consists of several subsystems:
(1) A filesystem that stores ACS instrument data files and "Quicklook" JPEGs in an
organized Network File System (NFS), (2) A \texttt{MySQL} database that stores image
metadata of each observation, (3) A \texttt{python}/\texttt{Flask}-based web application
for interacting with the filesystem and database, and (4) A \texttt{python} code library
(named \texttt{acsql}) that contains code for connecting to the database, ingesting new
data, logging production code execution, and building/maintaining the database and web
application.  Each of these subsystems are explained in further detail in the Methodology
section of this paper.

This paper aims to outline and detail the ACS Quicklook project as part of the Towson
University Computer Science Masters Program Graduate Project.  The remaining subsections
in this chapter discuss the motivation and use cases for this application, as well as
details on the underlying data structure on top of which this project was built.  Chapter
2 discusses related work to this project and how the ACS Quicklook project differs from
existing similar applications.  Chapter 3 details the implementations of each of the
ACS Quicklook subsystems.  Chapter 4 outlines the results of the project, namely the
project deliverables.  Lastly, chapters 5 and 6 conclude the paper with a discussion
of possible extensions and modifications to the application.

It should be noted that the work that went into this project by the authors was
accomplished on behalf of the Space Telescope Science Institute (STScI) located in
Baltimore, Maryland.  STScI is the home institution for instrument, data, and user
support of HST, the forthcoming James Webb Space Telescope
(JWST), and MAST.  STScI is part of the Association of Universities for Research in
Astronomy (AURA).


\subsection{Data Structure}

The design of the ACS Quicklook application, especially the database, is heavily
dependant on the underlying data structure of ACS FITS files.  As such, it is
important for the reader to understand this data structure and thus the next four
sections are dedicated to giving an overview on the subject.

\subsubsection{Filenames}

Each ACS data file is named in a consistent fashion:\newline

\texttt{$<$rootname$>$\_$<$filetype$>$.fits}\newline

\noindent where each \texttt{$<$rootname$>$} consists of nine unique alpha-numeric
characters, and \texttt{$<$filetype$>$} is one of several three-character filetype options
(discussed in proceeding section 1.1.4).  For example, one ACS observation has the rootname
\texttt{j6mf16lhq\_raw.fits} (Principle Investigator Gary Bernstein, observation
date \texttt{2016-09-22}).  Each character in the 9-character \texttt{rootname}
has meaning, and is discussed in section 5.2 of the Introduction to the HST
Data Handbooks (Smith et al., 2011).  The \texttt{.fits} extension at the end
of the filename signifies that the file is of FITS format.

Note about rootname caveat.

\subsubsection{FITS file structure}

Each ACS FITS file consists of several ``Extensions'', with each extension serving a purpose
to describe a particular aspect of the observation.  Each extension consists of two parts: (1)
an extension ``header'', which contain key/value pairs describing image metadata (for example,
\texttt{DATE-OBS = '2016-09-22'} indicates that the observation date was \texttt{2016-09-22})
(discussed in the next section), and (2) the extension data, which may be a binary table or,
more commonly, a multi-dimensional array of detector pixel values.

The type of extension data can also vary.  The most common extension data types are (1) `science'
(\texttt{SCI}), in which the extension data describe a scientific observation, (2) `error'
(\texttt{ERR}), in which the extension data describe the uncertainty in the pixel values of the
\texttt{SCI} data, and (3) `data quality' (\texttt{DQ}), in which the extension data describe
the quality of the pixel values for the detector (for example, they may indicate that certain
pixels were affected by cosmic rays durring the observation).  Typically, for a given file,
the 1st extension is the \texttt{SCI} extension, the 2nd extension is the \texttt{ERR} extension,
and the 3rd extension is the \texttt{DQ} extension.  Furthermore, the 0th extension typically has
no extension data and only an extension header that contains metadata that is common to all
extensions.  This is referred to as the `Primary Header'.

Tables 1-3 describe the different extensions of ACS FITS files for each of the three ACS
detectors.  Note that there are two sets of \texttt{SCI}/\texttt{ERR}/\texttt{DQ} extensions for
WFC since WFC is comprised of two separate CCD chips.

% Table for WFC extenions
\begin{table}[!t]
\renewcommand{\arraystretch}{1.5}
\caption{ACS/WFC FITS file extensions}
\label{wfc_extensions}
\centering
\begin{tabular}{|c|l|c|c|}
\hline
\rowcolor{gray} Extension & \multicolumn{1}{p{2cm}|}{\centering Purpose} & \multicolumn{1}{p{1.5cm}|}{\centering Image Dimensions \\ (pixels)} & Data Type \\
\hline
0 & Primary header & -- & String \\
\hline
1 & SCI, Chip 2 & (4096, 2048) & Float \\
\hline
2 & ERR, Chip 2 & (4096, 2048) & Float \\
\hline
3 & DQ, Chip 2 & (4096, 2048) & Integer \\
\hline
4 & SCI, Chip 1 & (4096, 2048) & Float \\
\hline
5 & ERR, Chip 1 & (4096, 2048) & Float \\
\hline
6 & DQ, Chip 1 & (4096, 2048) & Integer \\
\hline
\end{tabular}
\end{table}

% Table for HRC and SBC extenions
\begin{table}[!t]
\renewcommand{\arraystretch}{1.5}
\caption{ACS/HRC and ACS/SBC FITS file extensions}
\label{hrc_sbc_extensions}
\centering
\begin{tabular}{|c|l|c|c|}
\hline
\rowcolor{gray} Extension & \multicolumn{1}{p{2cm}|}{\centering Purpose} & \multicolumn{1}{p{1.5cm}|}{\centering Image Dimensions \\ (pixels)} & Data Type \\
\hline
0 & Primary header & -- & String \\
\hline
1 & SCI & (1024, 1024) & Float \\
\hline
2 & ERR & (1024, 1024) & Float \\
\hline
3 & DQ & (1024, 1024) & Integer \\
\hline
\end{tabular}
\end{table}


Over the years, there have been several tools written in various programming languages to
read in FITS files and automatically convert their extension data to multi-dimensional array
data types and their extension headers to dictionary data types.  For this project, the
\texttt{astropy.fits} \texttt{python} library is used extensivly to read and interact with
ACS FITS files (Robitaille et al., 2013).

\subsubsection{FITS file extension headers}

As mentioned in the previous section, each FITS extension contains a ``header'', which
contains key/value pairs of metadata associated with the extension data.  Such metadata
includes various data that describes the astronomical observation (e.g. target name,
exposure time, principle investigator name, etc.), telemetry of ACS or HST in general
at the time of observation (e.g. temperature of the ACS instrument, orientation of the
telescope pointing, position of the telescope relative to Earth, etc.) or the FITS file
itself (e.g. the number of extensions, file creation date, etc.). A subsection of an
example header is shown in Figure 2.

% Figure for header example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/header_example.png}
\caption{An example header.}
\label{fig1}
\end{figure}

Extension headers may contain a large number of keyword/value pairs.  Some extension
headers contain upwards of 300 keywords, while others may contain only $\sim$40 keywords.

\subsubsection{FITS filetypes for ACS}

As discusses in section 1.1.1, each ACS observation may result in several FITS filetypes.
Each filetype describes the observation in a different way.  The set of available
filetypes for a given observation is dependent on the characteristics of the observation,
the details of which are beyond the scope of this paper.  Also beyond the scope of this
paper are the vast details that surround each filetype; each one has a different scientific
application that is not important to understanding the ACS Quicklook project.  However,
to provide at least some context, below we give a brief description of each possible
filetype that a given observation may contain:

\begin{itemize}
  \item \textbf{raw} - The raw, uncalibrated data that comes directly from HST
  \item \textbf{flt} - nominally calibrated data
  \item \textbf{flc} - nominally calibrated data plus corrected for Charge Transfer Efficieny (CTE) deficits.
  \item \textbf{drz} - Geometric distortion-corrected data
  \item \textbf{drc} - Geometric distrotion-corrected plus CTE corrected data
  \item \textbf{spt} - Telescope telemetry data
  \item \textbf{jit} - Telescope pointing data
  \item \textbf{jif} - Telescope drifting data
  \item \textbf{crj} - Cosmic ray rejected data
  \item \textbf{crc} - Cosmic ray rejected plus CTE corrected data
  \item \textbf{asn} - Observation association table.
\end{itemize}

As noted earlier, a given observation may not result in the set of all possible filetypes.
For example, the observation \texttt{j6mf16lhq} only has the filetypes \texttt{raw},
\texttt{flt}, \texttt{jit}, \texttt{jif}, and \texttt{spt}.

\subsection{Key Metadata}

There are several metadata key/value pairs that are particulary important for the
ACS Quicklook application, specifically the web application.  For some reference,
and context, these metadata are briefly described below.  Note that the \texttt{rootname}
and \texttt{proposal$\_$type} are not metadata from extension headers, but rather are
metadata that were explicitly added to the database schema.\newline

\textit{APERTURE} - The portion of the \texttt{WFC}, \texttt{HRC}, or \texttt{SBC} detector that
that was used during an observation.  Can either be the entire detector (called a ``full-frame
image'') (e.g. \texttt{WFC}), or a subsection of the detector (called a ``subarray'') (e.g.
\texttt{WFC1-1K}).\\

\textit{DATE-OBS} - The date of the observation in the format \texttt{YYYY-MM-DD}, measured in
Universal Time (e.g. \texttt{'2017-08-05'}).\\

\textit{DEC$\_$TARG} - The declination of the target (i.e. the angular distance the target north or south
of the celestial equator) (e.g. \texttt{41.2842}).\\

\textit{DETECTOR} - The detector used for the observation.  Can either be \texttt{WFC}, \texttt{HRC},
or \texttt{SBC}.\\

\textit{EXPFLAG} - Indicates if an observation was interrupted (e.g. \texttt{INTERRUPTED}) or not
(e.g \texttt{NORMAL}).\\

\textit{EXPSTART} - The exposure start time of the observation, in units of Modified Julian Date
(e.g. \texttt{52473.8}).\\

\textit{EXPTIME} - The exposure duration of the observation, in units of seconds (e.g. \texttt{1000.0}).\\

\textit{FILTER1} - The selected element from the \texttt{ACS} filter wheel \# 1 (e.g. \texttt{F606W}).\\

\textit{FILTER2} - The selected element from the \texttt{ACS} filter wheel \# 1 (e.g. \texttt{F814W}).\\

\textit{IMAGETYP} - The type of exposure for the observation (e.g. \texttt{BIAS}, \texttt{EXT}, etc.).\\

\textit{OBSTYPE} - The type of observation, either \texttt{IMAGING}, \texttt{SPECTROSCOPIC},
\texttt{CORONOGRAPHIC}, or \texttt{INTERNAL}.\\

\textit{proposal$\_$type} - The type of proposal that the observation belongs to, such as Calibration
(i.e. \texttt{CAL}) or General Observer (i.e. \texttt{GO}).\\

\textit{PROPOSID} - The proposal number that the observation belongs to (e.g. \texttt{10695}).\\

\textit{RA$\_$TARG} - The right ascension of the target (i.e. the angular distance of the target east and west
on the celestial sphere) (e.g. \texttt{49.5375}).\\

\textit{rootname} - The 8-character unique rootname of the observation (e.g. \texttt{j59l5401}).\\

\textit{SUBARRAY} - A boolean flag that indicates if the observation is a full-frame \texttt{APERTURE}
(i.e. \texttt{0}) or a subarray \texttt{APERTURE} (i.e. \texttt{1}).\\

\textit{TARGNAME} - The name of the target (e.g. \texttt{M87}, \texttt{NGC-4536}, \texttt{ANDROMEDA-I}, etc.).\\

\textit{TIME-OBS} - The time of the start of the observation in the format \texttt{HH:MM:SS}, measured in
Universal Time (e.g. \texttt{14:21:56}).\\


\subsection{Motivation}

The motivation for the ACS Quicklook system is driven by several shortcomings of the
FITS file structure as well as the current capabilities of MAST from a specific
user perspective (inteded users and their use cases are discussed in section 1.2).
Some of these shortcomings are described below along with the intended way the
ACS Quicklook application will address them.\newline

\textit{Data retreival letency:} Currently, users who wish to retreive data from
the MAST archive must submit a retreival request via the MAST online interface.
Once the retreival request is processed (usually automatically unless it is a
request of a large number of datasets), the data are either transfered to the user
directly via \texttt{sftp}, transfered to a "staging area" in which the user can
log into and copy the data via \texttt{ftp} at their leisure, or sent by mail via
DVD, depending on which option the user selects.  In the case of any one of these
options, the time between a download request and the the time in which the user
has fully retreived the data is a non-significant amount of time.  In the fastest
scenario of the \texttt{sftp} option, a typical request can take minutes to hours
to be completed.  The ACS Quicklook system attempts to circumnavigate this retreival
process by making the full data products instantly available via read-only access of
the filesystem subystem, as well as a subset of the data products (and corresponding
metadata) instantly available to view through the web application.

\textit{File I/O:} Users who

\textit{Data redundancy:} Something.

\textit{Data discovery:} Something


\subsection{Use Cases}
The intended user of ACS Quicklook are ACS instrument scientists, analysts,
or scientific users who wish to perform one or more of the following use cases:

1. View


% Related Work
\section{Related Work}\label{sec:related_work}

Topics to discuss:

1. The MAST archive
2. The MAST portal
3. The WFC3/Quicklook project
4. Other Astronomy Institutions
5. How ACS/Quicklook is different


% Methodology
\section{Methodology}\label{sec:methodology}

In this chapter, we disucss the methods by which we implemented the various subsystems
of the ACS Quicklook system.  Additionally, we discuss the programming standards and
standard workflows that were employed to promote code quality such as readability,
maintainability, extensibility, etc; we believe that this aspect of the project is
at least equaly important to the system as its individual components.


\subsection{Version control}

All code associated with this project (including this paper iteself) is version
controlled using the \texttt{git} Version Control System (VCS) (git, 2017).
The \texttt{git} repository for the project is named \texttt{acsql}.
The \texttt{git} repository is also hosted on \texttt{GitHub}, a repository
hosting service (GitHub, 2017), and is publicly available at
\url{http://github.com/spacetelescope/acsql/}.

Several feature branches of the code were created throughout the building of this project
such that the \texttt{master} branch (which is considered the ``production'' branch)
always contained operational code (while the code in the branches may contain unfinished
implementations).  Such branches include \texttt{create-database} (for implementation of
the database schema), \texttt{add-logging} (for implementation of system logging),
\texttt{build-ingest} (for implementation of data ingestion software), and
\texttt{web-application} (for implementation of the web application).  For each merge of a
feature branch, a \texttt{tag} and \texttt{release} was created for the \texttt{master} branch,
which allows a specific version of the \texttt{master} branch to be saved in the
repository.  These releases are available at
\url{https://github.com/spacetelescope/acsql/releases}.

Additionally, using \texttt{GitHub} allowed for issue tracking of bugs, features, and
potential enhancements to the code repository.  Current open issues of the repository
can be found at \url{https://github.com/spacetelescope/acsql/issues}.


\subsection{Programming and Documentation Standards}

All code contained within this project was written to adhere to specific standards and
conventions, namely (1) the \texttt{PEP8} Style Guide for \texttt{python} code (van Rossum, 2001),
(2) The \texttt{PEP257} \texttt{python} guide for module and function docstring conventions
(Goodger, 2001), and (3) the \texttt{numpydocs} documentation standard (NumPy Documentation,
2017).  More details on each of these standards and conventions are given below.

The \texttt{PEP8} Style Guide for \texttt{python} code (abbreviated for `Python Enhancement
Proposal \#8`) documents \texttt{python} coding conventions including variable naming,
spacing, line length, module layout, function layout, comments, and design patterns.  Only
in specific cases were these conventions not followed, such as using a single line of code,
even if it exceeded the recoomended 80 characters, to allow for greater readability.  By
following these conventions, the style of the \texttt{acsql} code is constistent amongst
each module and attempts to reflect the style of industry-grade \texttt{python} code.

The \texttt{PEP257} guide for docstring conventions describes standard conventions used
for function and module docstrings (i.e. the API documentation found in block
comments at the beginning of modules or immediately after function declarations).  Like
\texttt{PEP8}, following these conventions ensure consistency amongst the \texttt{acsql}
code documentation.  Furthermore, the \texttt{numpydocs} documentation convention provides
some additional details on top of the \texttt{PEP257} conventions and is used in many
\texttt{python} packages including the \texttt{numpy} (numerical \texttt{python}) and
\texttt{scipy} (scientific \texttt{python}) packages (van der Walt et al., 2011).  Figure N
shows an example of these conventions, taken from the
\texttt{ascql.ingest.ingest.get$\_$proposal$\_$type} function.

% Figure for docstring convention example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/docstrings.png}
\caption{An example of the \texttt{PEP257} and \texttt{numpydoc} docstring conventions,
using the \texttt{get$\_$proposal$\_$type} function from \texttt{acsql.ingest.ingest}.}
\label{fig1}
\end{figure}

Another benefit to using \texttt{PEP257} and \texttt{numpydoc} docstring conventions is
that API documentation creation tools such as \texttt{sphinx} (Brandi et al., 2007) or
\texttt{epydoc} (Loper, 2004) can automatically convert the docs into other output
formats such as \texttt{HTML} and \texttt{PDF}.  For this project, we use
\texttt{sphinx} to convert API documentation to \texttt{HTML}, and host the webpages online
using the \texttt{readthedocs}, which is an open-source, community supported tool for
hosting and browing documentation (Read the Docs, 2017). The documentation for
\texttt{acsql} is hosted at \url{http://acsql.readthedocs.io/}.  The output documentation
as seen on \texttt{readthedocs} for the example function in figure N is provided in Figure N.

% Figure for docstring convention example in readthedocs
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/readthedocs.png}
\caption{The \texttt{readthedocs} documentation for the \texttt{acsql} example function
seen in Figure N.}
\label{fig1}
\end{figure}


\subsection{Filesystem: Archive of ACS data}

The \texttt{acsql} filesystem is a Network File System (NFS) that stores all on-orbit
ACS data on disk in an organized set of directories and subdirectories hosted at STScI. Figure N shows
an example of this directory structure: The parent directory is the first four characters
of the 9-character \texttt{rootname}, which maps directly to an individual \texttt{PROPOSID}.
The subdirectories of the parent directories are named after the full 9-character
\texttt{rootname} such that each parent directory contains the \texttt{rootname} subdirectories
that were observed for that particular \texttt{PROPOSID}.  Each \texttt{rootname}
subdirectory contains every available filetype (as described in Section 1.1.4) for the
particular observation is stored.

% Figure for acsql filesystem size over time
\begin{figure}[!t]
\centering
\includegraphics[width=2.0in]{./figures/filesystem_structure.png}
\caption{A representation of the directory structure within the \texttt{acsql} filesystem,
using a few observations as an example.}
\label{fig1}
\end{figure}

Figure N shows how the total size of the filesystem has evolved over the lifetime of the
mission; currently, the filesystem occupies $\sim${40} TB of storage space.  Note that the
file sizes across the detectors and across the various filetypes may vary depending on the
nature of the particular obseration (for example, full-frame observations result in larger
file sizes than subarray observations, calibrated filetypes have larger file sizes than
un-calibrated filetypes, etc.).

% Figure for acsql filesystem size over time
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/filesystem_size.png}
\caption{The size of the \texttt{acsql} filesystem as a function of observation
date.}
\label{fig1}
\end{figure}


\subsection{Filesystem: Archive of JPEGs and Thumbnails}

In addition to the ACS data products described in the last section, the
\texttt{acsql} filesystem also stores ``Quicklook'' \texttt{JPEG} and
\texttt{thumbnail} images of each \texttt{RAW}, \texttt{FLT}, and \texttt{FLC}
filetype (when applicable) in an organized directory structure.  These
images are used by the \texttt{acsql} web application to allow users to
quickly and easily view the contents of the data without having to
pysically open the corresponding \texttt{.fits} files.

The \texttt{JPEG}images are are generated by taking the two-dimensional
data from the \texttt{SCI} extension(s), sigma-clipping the top and bottom
1\% of the values (as to avoid large outlier values and enhance the scaling
of the image), and saving the data to a a \texttt{JPEG} format.  The
\texttt{thumbnail} images are created by simply resizing the corresponding
\texttt{JPEG} into a 128x128 pixel image and saving to a \texttt{.thumb}
extension; the purpose of these \texttt{thumbnail} images are to be able
to view many of them on a single webpage in the \texttt{acsql} web
application.  An example of a \texttt{JPEG} image and its corresponding
\texttt{thumbail} is shown in Figure N.

% Figure for JPEG and thumbnail example
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/jpeg_and_thumbnail.png}
\caption{An example of a \texttt{JPEG} image (left) and its corresponding
\texttt{thumbnail} image using example dataset \texttt{jcs718koq}.}
\label{fig1}
\end{figure}

Unlike the ACS data products portion of the filesystem, the \texttt{JPEG}
and \texttt{thumbnail} portions of the filesystem are organized
based on the 5-digit \texttt{PROPOSID} of the corresponding observation
instead of the first four characters of the \texttt{rootname}.  This
design was chosen as a means to simplify the design of the web application;
users often which to view data based on the 5-digit \texttt{PROPOSID} and
less often on the details of the \texttt{rootname}.  An example of this
sturcture is shown in Figure N.  Note that the \texttt{thumbail} filesystem
only contains thumbnails created from \texttt{FLT} filetypes, since thumbnails
are only inteded for navigation and quick-viewing.

% Figure for JPEG and thumnail directory structure
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/jpeg_filesystem.png}
\caption{A representation of the directory structure for the \texttt{JPEG} (left)
and \texttt{thumbail} (right) portion of the \texttt{acsql} filesystem, using a
few observations as an example.}
\label{fig1}
\end{figure}


\subsection{Database: Relational Schema}

Another major component of the \texttt{acsql} project is a relational database
that stores all \texttt{FITS} header key/value pairs for each ACS filetype and
\texttt{FITS} file extension across all on-orbit ACS observations.  Such a
database allows users to perform relational queries for any observational
metadata.

To accomplish this, we implemented the relational schema shown in Figure N.  The
\texttt{acsql} database contains 111 tables in total: one \texttt{master} table
which contains basic information about each \texttt{rootname} that is important
for the \texttt{acsql} database in general, one \texttt{datasets} table which
indicate which filetypes are available for a particular \texttt{rootname}, and
109 `header' tables which stores the header key/value pairs, one for each
\texttt{detector}/\texttt{filetype}/\texttt{extension} combination (e.g.
\texttt{wfc$\_$raw$\_$0}).  Each of these tables are described in detail below.

% Figure for acsql database schema
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/schema.png}
\caption{The relational database schema for the \texttt{acsql} database.}
\label{fig1}
\end{figure}

The \texttt{master} table contains information that is particularly useful
for maintaining and using the \texttt{acsql} database.  Its primary key is
the first 8 characters of the 9-character \texttt{rootname} for the partiuclar
observation (recall from section 1.1.1 that only the first 8 characters of
a \texttt{rootname} are actually unique).  The \texttt{path} column contains
the location of the observation in the \texttt{acsql} filesystem.  The
\texttt{first$\_$ingest$\_$date} and \texttt{last$\_$ingest$\_$date} contains the date
in which the observation was first inserted into the database and the date
in which the observation was most recenly updated in the database, respectively.
The \texttt{last$\_$ingest$\_$date} allows the database maintainer to determine when
data in the database may become outdated and require re-ingestion.

The \texttt{datasets} table lists which filetypes are available for each
observation.  If a particular filetype is available for the given \texttt{rootname},
the value for the appropriate column in the table is the full
\texttt{<rootname>$\_$<filetype>.fits} filename (for example, the \texttt{raw} column
contains the value \texttt{jcs718koq$\_$raw.fits} for \texttt{rootname} \texttt{jcs718ko}).
If a particular filetype is not available, the value of the column is \texttt{NULL}.
This table allows a user to determine which header tables are queryable for a given
\texttt{rootname}.  The \texttt{rootname} in the \texttt{datasets} table acts as both
a primary key for the table as well as a foreign key that maps to the \texttt{rootname}
of the \texttt{master} table.

The remaining 109 tables were designed to be in direct correspondance with the
header metadata key/value pairs found in observations files; each column is named in
the same manner as the header keys, with the value of that column reflecting the header
value. There is one table for each \texttt{detector}, \texttt{filetype},
and \texttt{extension} combination; collectively, these are referred to as the `header'
tables.  Like with the \texttt{datasets} table, the \texttt{rootname} column serves as a
primary key for the header tables as well as a foreign key that maps to the \texttt{rootname}
of the \texttt{master} table.


\subsection{Database: \texttt{MySQL} + \texttt{SQLAlchemy}}

The \texttt{acsql} database is stored on a \texttt{MySQL} server (\texttt{Version 5.6})
(Oracle, 2017) that is hosted at STScI.  The database schema was implimented using
\texttt{SQLAlchemy}, which is an open-source SQL toolkit and Object Relational Mapper (ORM) for
\texttt{python} (Bayer, 2006).  As an ORM, \texttt{SQLAlchemy} enables \texttt{python} classes
to be easily translated to \texttt{SQL}-based database tables, and vice versa.  Additionall,
\texttt{SQLAlchemy} provides \texttt{python} methods for connecting to a SQL-based database and
performing typical \texttt{SQL} tasks such as inserts, updates, and queries.

There are several key functions and classes that were used to construct the \texttt{acsql}
database (all of which can be found in the \texttt{acsql.database.database$\_$interface.py} module).
One such function is the \texttt{load$\_$connection}, as shown in Figure N.  This function creates
three \texttt{SQLAlchemy} objects that are used to establish a connection with the \texttt{acsql}
database: \texttt{engine}, \texttt{base}, and \texttt{session}, each described below.

The \texttt{engine} object contains the Python Database API Specification (also
known as \texttt{DBAPI}), which provides a low-level API for \texttt{python}-specific, commonly-used
database tasks (Lemburg, 2017).  It is created from the \texttt{sqlalchemy.create$\_$engine} method, which
requires a user-supplied \texttt{connection$\_$string}.  The \texttt{connection$\_$string} is a string
that contains information about the type of database, the specific database dialect being used, and
the user credentials (e.g. username, password, port number, and host server name).  In the case
of the \texttt{acsql}, this connection string takes the form of
\texttt{'mysql+pymysql://username:password@host:port/acsql'}.  The \texttt{connection$\_$string} is
imported from a user supplied \texttt{config} file within the \texttt{acsql} library
(as will be discussed in section 3.9).

The \texttt{base} object serves as a base class for declarative class definitions (i.e. the
classes that are used to define the database tables).  It is created from the
\texttt{sqlalchemy.ext.declarative.declatative$\_$base} method.  Perhaps most importantly, the
\texttt{base} object contains methods for creating and dropping tables from the class
definitions (e.g. \texttt{base.metadata.create$\_$all()} and \texttt{base.metadata.drop$\_$all()},
respectively).

The \texttt{session} object provides a primary usage interface for database operations, and
is created via the \texttt{sqlalchemy.sessionmaker} method, which takes as a parameter the
\texttt{engine} object.  The methods of the \texttt{session} object are primarily used to
query the database (i.e. \texttt{session.query()}) as well as commiting inserts or updates (i.e.
\texttt{session.commit()}).

% Figure for load_connection in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/load_connection.png}
\caption{The \texttt{load$\_$conenction} function, which is used to build a connection to the
\texttt{acsql} database}.
\label{fig1}
\end{figure}

The \texttt{master} and \texttt{datasets} tables were implemented via explicit class definitions in
\texttt{database$\_$interface}, and are shown in Figures N and N, respectively.  Each table column is
defined using the \texttt{sqlalchemy.Column} object, which is a class that can be initialized
with the datatype that will be stored in the column (e.g. \texttt{String}, \texttt{Float}, \texttt{Integer},
etc.) as well as parameters that set SQL-like constraints and parameters on the column values.  These
include, but are not limited to, primary keys (e.g. the \texttt{primary$\_$key=True} parameter in the
\texttt{master.rootname} column), foreign key constrains (e.g. the \texttt{ForeignKey} constraint in the
\texttt{datasets.rootname} column), uniqueness constraints (e.g. the \texttt{unique=True} parameters in
the \texttt{master.path} column), and \texttt{NULL} constraints (e.g. the \texttt{nullable=False} parameter
in the \texttt{master.first$\_$ingest$\_$date} column).  \texttt{SQLAlchemy} determines the name of the
table via the \texttt{$\_$$\_$tablename$\_$$\_$} attribute, and determines the name of the columns by
the name of the variable used to initialize each \texttt{Column} object.

% Figure for master table in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/master_table.png}
\caption{The class definition for constructing the \texttt{master} table via \texttt{SQLAlchemy}.}
\label{fig1}
\end{figure}

% Figure for datasets table in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/datasets_table.png}
\caption{The class definition for constructing the \texttt{datasets} table via \texttt{SQLAlchemy}.}
\label{fig1}
\end{figure}

Since there are 109 header tables, some of which have hundreds of columns, it is not practical to construct
a class definition for each table in a similar manner to that of the \texttt{master} and \texttt{datasets}
table.  Instead, these class definitions were implemented via the \texttt{database$\_$interface.orm$\_$factory}
function, which is a factory function that creates and returns a class definition for each header table, based on
the given \texttt{class$\_$name} that reflects the \texttt{detector}/\texttt{filetype}/\texttt{extension} combination
(e.g. \texttt{wfc$\_$raw$\_$0}).  The \texttt{orm$\_$factory} function is shown in Figure N.  Similar to the
\texttt{Master} and \texttt{Datasets} classes, some of the columns in the \texttt{orm$\_$factory} function are
explicitly defined via the \texttt{SQLAlchemy} \texttt{Column} class.  However, the columns that correspond to
header key/value pairs are defined in a separate function named \texttt{define$\_$columns}, shown in Figure N.

% Figure for orm_factory in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/orm_factory.png}
\caption{The \texttt{orm$\_$factory} function, used to define class definitions for header tables.}
\label{fig1}
\end{figure}

% Figure for define_columns in database_interface
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/define_columns.png}
\caption{The \texttt{define$\_$columns} function, used to define columns used in the header tables.}
\label{fig1}
\end{figure}

The purpose of the \texttt{define$\_$columns} function is to define \texttt{SQAlchemy} \texttt{Column}
objects for each header keyword in the headers of the particular \texttt{detector}/\texttt{filetype}/\texttt{extension}
combination (provided in the given \texttt{class$\_$name} parameter).  This is accomplished by reading in a text
file (named \texttt{<class$\_$name>.txt} that contains the header keywords and their datatype (one per line) for
the given \texttt{class$\_$name}. An portion of an example text file is shown in Figure N.

% Figure for table defintion text file
\begin{figure}[!t]
\centering
\includegraphics[width=0.8in]{./figures/table_definition.png}
\caption{The contents of an example text file used to define the columns of a header table in the
\texttt{define$\_$columns} function. The example table used here is the \texttt{wfc$\_$asn$\_$0} table.}
\label{fig1}
\end{figure}

Furthermore, the 109 text files used to define the header table columns are also generated in an
automated fashion via the \texttt{acsql.database.make$\_$tabledefs.py} module.  This module uses
a set of example FITS files to scrape its header contents, determine all of the header keywords and
their datatypes, and write the results to a text file.  Similarly, the
\texttt{acsql.database.update$\_$tabledefs.py} is used to add new header keywords by comparing the
header contents of a given FITS file and the existing column definition text files\footnote{New header
keywords are occaisonally introduced to ACS data proceeding updates to its calibration software}.

With the implementation of the \texttt{orm$\_$factory} and \texttt{define$\_$columns} function, it is
then trivial to create class definitions for each of the 109 header tables.  An example of this is
shown in Figure N, where the several of the \texttt{WFC} header tables are defined.

% Figure for orm_factory calls
\begin{figure}[!t]
\centering
\includegraphics[width=1.5in]{./figures/orm_factory_calls.png}
\caption{An example of how the \texttt{orm$\_$factory} function is called to create class
defintions for the header tables.}
\label{fig1}
\end{figure}

With the \texttt{master}, \texttt{datasets}, and each of the 109 header tables defined in the
\texttt{database$\_$interface} module, creating the database tables on the \texttt{MySQL} server
is accomplished by executing the \texttt{base.metadata.create$\_$all()} method.


\subsection{Data ingestion software: Algorithm}

Another critical component of the ACS Quicklook system are the modules that are used to ingest
data into the \texttt{acsql} database and to create the ``Quicklook'' JPEGs and thumbails.
By the term `ingest', we refer to the following algorithm:

1. \textbf{\textit{Identify newly available public ACS data in the filesystem:}}  This is accomplished by
comparing the list of \texttt{rootnames} in the filesystem with the list of \texttt{rootnames}
in the \texttt{master} table of the \texttt{acsql} database.  Any \texttt{rootnames} that
exist in the filesystem but not in the database are considered new \texttt{rootnames} to
be ingested.

2. \textbf{\textit{Loop over each \texttt{rootname} (in a parallelized manner):}}  The ingestion
software (i.e. the \texttt{acsql.ingest.ingest} module), takes as input a single
\texttt{rootname}, such that if there are multiple \texttt{rootnames} to be ingested, the
calls to the ingestion module can be parallelized over many CPUs.  The ingestion of one
\texttt{rootname} does not depend on the ingestion of another, nor is the order of which
files are ingested important.  Please note that steps 3 through N are written from the
perspective that a single \texttt{rootname} is being ingested (i.e. inside of the loop.)

3. \textbf{\textit{Update the \texttt{master} table with information about the \texttt{rootname}:}}
At this point, the \texttt{master} table can be updated with metadata pertaining to the
\texttt{rootname}.  A generic \texttt{insert$\_$or$\_$update} function was written
(available in the \texttt{acsql.utils.utils} module) to determine if an entry should be
inserted (in the case of first-time ingestion) or updated (in the case of re-ingestion).
This function uses various \texttt{sqlalchemy} methods and the class definitions described
in section 3.6 to perform the \texttt{insert} or \texttt{update} operation.  The
\texttt{insert$\_$or$\_$update} function is shown in Figure N.

% Figure for insert_or_update
\begin{figure}[!t]
\centering
\includegraphics[width=3.5in]{./figures/insert_or_update.png}
\caption{The \texttt{insert$\_$or$\_$update} function from the \texttt{acsql.utils.utils}
module, used at various times during the data ingestion process to determine if an
entry should be inserted or updated in the \texttt{acsql} database.}
\label{fig1}
\end{figure}

4. \textbf{\textit{Loop over the available \texttt{filetypes} for the given \texttt{rootname}:}}
The available \texttt{filetypes} are determined by traversing down a level in the tree
structure of the filesystem and identifying which files are present. Once determined,
the ingestion algorithm processes each \texttt{<rootname>$\_$<filetype>.fits} file
individually.  Please note that steps 5 through N are written from the perspective that
a single file is being ingested (i.e. inside of the next nested loop).

5. \textbf{\textit{Create a \texttt{python} dictionary with metadata about the file}:}  To reduce
the amount of variables being passed around to various functions, a data container
in the form of a \texttt{python} dictionary data type is created to hold metadata needed
by the remainder of the ingestion process.  We refer to this data container as the
\texttt{file$\_$dict}.  The \texttt{file$\_$dict} contains metadata such as the absolute
path of the file in the filesystem, the \texttt{filetype}, the available FITS file
extensions of the file, and the absolute paths to which the ``Quicklook'' JPEGs and
Thumbnails will be written.

6. \textbf{\textit{For each FITS file exentension, extract the header information and update
the appropriate header table in the \texttt{acsql} database:}}  The header information
is read into a \texttt{python} dictionary via the \texttt{astropy.io.fits} module.
Besides some minor fixes for a few corner cases (such as converting hypens in header keys
to underscores as to avoid \texttt{python} errors), it is rather trivial to perform
and \texttt{insert} or \texttt{update} operation via the \texttt{insert$\_$or$\_$update}
function (see Figure N).

7. \textbf{\textit{Update the \texttt{datasets} table for the given \texttt{filetype}:}}
At this point, an entry in the \texttt{datasets} table is either inserted if it is the
first \texttt{filetype} for the \texttt{rootname} being ingested, or updated if a
\texttt{filetype} under the same \texttt{rootname} had already been ingested.

8. \textbf{\textit{If the \texttt{filetype} is either \texttt{raw}, \texttt{flt}, or
\texttt{flc}, then create a ``Quicklook'' JPEG image:}}  JPEGs are produced only for
\texttt{raw}, \texttt{flt}, and \texttt{flc} \texttt{filetypes}, since it are these
\texttt{filetypes} that contain actual two-dimensional image data.  The image data are
read into multidimensional \texttt{numpy} array data types via the
\texttt{astropy.io.fits} module.  The data are then rescaled as to avoid an undesirable
image stretch caused by extremely high or low-valued pixels, and saved to a \texttt{.jpg}
format.

9. \textbf{\textit{If the \texttt{filetype} is \texttt{flt}, then create a ``Quicklook''
Thumbnail image:}} Thumbnail images are only produced for \texttt{flt} filetypes since they
are only meant to be viewed as a means to discover the larger JPEG images via the
\texttt{acsql} web application.  Thumbnails are generated by simply opening up the
corresponding \texttt{flt} JPEG and resizing it to 128x128 pixels.

This workflow is encapsulated within several modules across the \texttt{acsql.scripts} and
\texttt{acsql.ingest} subpackages, as will be desribed in section 3.9.  These modules are
intended to be executed daily (as an automatically-spawned process) as to keep the ACS
Quicklook system up-to-date on any public data as it becomes available.


\subsection{Data ingestion software: \texttt{logging}}

Since the data ingestion software is intended to be executed not by humans but rather
by an automatic process, we implemented a system by which the status of the execution
of ingest can be logged to an output text file and analyzed at a later time.  Such log
files can be used to assess if there was any issues with the ingestion process, including
but not limited to:


\subsection{Web Application}

\subsection{\texttt{acsql} Library}


% Results
\section{Results}\label{sec:results}

Topics to discuss:
1. GitHub repository
2. ReadTheDocs documentation repository
3. Quantification of Database records
4. Quantification of Code repository
5. Website location



% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a
% line do not exceed the text width or a line break will occur.
%
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Conclusion
\section{Conclusion}\label{sec:conclusion}
The conclusion goes here.

% Discussion
\section{Discussion}\label{sec:discussion}
Topics to discuss:

1. Possible simplification based on MAST archive
2. Possible extensions to other insturments

% Appendices
\appendices
\section{\texttt{acsql} code}
Appendix one text goes here.


% use section* for acknowledgment
\ifCLASSOPTIONcompsoc
  \section*{Acknowledgments}
\else
  \section*{Acknowledgment}
\fi
  The authors would like to thank...


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi


% Referecnes
\begin{thebibliography}{1}

\bibitem{IEEEhowto:numpydoc}
\emph{A Guide to NumPy/SciPy Documentation}, [Online; accessed 2017-08-05], available at
\url{https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt}

\bibitem{IEEEhowto:avila}
Avila, R., et al., 2017, \emph{ACS Instrument Handbook}, Version 16.0 (Baltimore: STScI)

\bibitem{IEEEhowto:bayer}
Bayer, M., 2006â€“, \emph{SQLAlchemy: The database toolkit for Python}, [Online; accessed 2017-02-21],
available at \url{http://www.sqlalchemy.org/}.

\bibitem{IEEEhowto:brandi}
Brandi, G., et al., 2007, \emph{Sphinx: Python Documentation Generator}, available at
\url{http://www.sphinx-doc.org/en/stable/}.

\bibitem{IEEEhowto:fits}
\emph{Definition of the Flexible Image Transport System (FITS): The FITS Standard}, 2008,
International Astronomical Union FITS Working Group, available at
\url{https://fits.gsfc.nasa.gov/standard30/fits_standard30aa.pdf}.

\bibitem{IEEEhowto:git}
\emph{git}, [Online; accessed 2017-08-05], available at \url{https://git-scm.com}.

\bibitem{IEEEhowto:github}
\emph{GitHub}, [Online; accessed 2017-08-05], available at \url{https:/github.com}.

\bibitem{IEEEhowto:goodger}
Goodger, D., 2001, \emph{PEP 257 -- Docstring Conventions}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0257/}.

\bibitem{IEEEhowto:lemburg}
Lemburg, M., 2017, \emph{PEP 249 -- Python Database API Specification v2.0}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0249/}.

\bibitem{IEEEhowto:loper}
Loper, E., 2004, \emph{Epydoc: Generating API Documentation in Python}, Proceedings of the
Second Annual Python Conference, available at \url{http://epydoc.sourceforge.net/}.

\bibitem{IEEEhowto:oracle}
\emph{MySQL 5.6 Reference Manual}, Oracle, [Online; accessed 2017-08-13], available at
\url{https://dev.mysql.com/doc/refman/5.6/en/}

\bibitem{IEEEhowto:readthedocs}
\emph{Read the Docs}, [Online; accessed 2017-08-05], available at \url{https://readthedocs.org}.

\bibitem{IEEEhowto:robitaille}
Robitaille, T.P., et al., 2013, \emph{Astropy: A community Python package for astronomy},
Astronomy \& Astrophysics, 558, A33.

\bibitem{IEEEhowto:smith}
Smith, E., et al., 2011, \emph{Introduction to the HST Data Handbooks}, Version 8.0 (Baltimore: STScI)

\bibitem{IEEEhowto:mast}
\emph{The Barbara A. Mikulski Archive for Space Telescopes}, [Online; accessed 2017-07-30],
available at \url{https://archive.stsci.edu/}.

\bibitem{IEEEhowto:vanDerWalt}
van der Walt, S., Colbert, C., and Varoquaux, G., 2011, \emph{The NumPy Array: A Structure for
Efficient Numerical Computation}, Computing in Science \& Engineering, 13, 22-30.

\bibitem{IEEEhowto:vanRossum}
van Rossum, G., 2001, \emph{PEP 8 -- Style Guide for Python Code}, Python Developer's Guide,
available at \url{https://www.python.org/dev/peps/pep-0008/}.

\end{thebibliography}


% that's all folks
\end{document}
